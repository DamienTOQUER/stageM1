#include<iostream>#include<fstream>#include<list>#include<vector>#include<string>#include<cmath>using namespace std;#include "const.h"#include "complex.h"#include "potential.h"#include "initial.h"#include "fourier.h"#include "opemath.h"void maffiche(list<Complex> & subdiag, list<Complex> & diag, list<Complex> & supdiag){	list<Complex>::iterator it;	cout<<"Subdiag:"<<subdiag.size()<<endl;	for(it = subdiag.begin(); it!=subdiag.end(); it++){		it->affiche();	}	cout<<"Diag:"<<diag.size()<<endl;	for(it = diag.begin(); it!=diag.end(); it++){		it->affiche();	}	cout<<"Supdiag:"<<supdiag.size()<<endl;	for(it = supdiag.begin(); it!=supdiag.end(); it++){		it->affiche();	}}void enregistre(list<Complex> & psi, unsigned int j){	ofstream flux("../resultat_temp/psi"+to_string(j)+".txt");	list<Complex>::iterator it;	flux<<"t="<<j*Const::pas_t<<" "<<"position"<<" "<<"norme"<<" "<<"phase"<<endl;	double x = Const::min_x;	for(it = psi.begin(); it!=psi.end(); it++){		flux<<x<<" "<<(*it).get_norme()<<" "<<(*it).get_phase()<<endl;		x+=Const::pas_x;	}}void enregistre(vector<Complex> & psi, unsigned int j){	ofstream flux("../resultat_temp/psi"+to_string(j)+".txt");	flux<<"t="<<j*Const::pas_t<<" "<<"position"<<" "<<"norme"<<" "<<"phase"<<endl;	for(unsigned int i=0; i<Const::n_x; i++){		flux<<1.*Const::min_x+1.*i*Const::pas_x<<" "<<psi[i].get_norme()<<" "<<psi[i].get_phase()<<endl;	}}void enregistre(vector<double> & psi, unsigned int j){	ofstream flux("../resultat_temp/psi"+to_string(j)+".txt");	flux<<"t="<<j*Const::pas_t<<" "<<"position"<<" "<<"norme"<<" "<<"phase"<<endl;	for(unsigned int i=0; i<Const::n_x; i++){		flux<<1.*Const::min_x+1.*i*Const::pas_x<<" "<<psi[i]<<endl;	}}void enregistref(list<Complex> & psi, unsigned int j){	ofstream flux("../resultat_temp/psi"+to_string(j)+".txt");	list<Complex>::iterator it;	flux<<"t="<<j*Const::pas_t<<" "<<"position"<<" "<<"norme"<<" "<<"phase"<<endl;	double x = 0;	for(it = psi.begin(); it!=psi.end(); it++){		flux<<x<<" "<<(*it).get_norme()<<" "<<(*it).get_phase()<<endl;		x+=2.*M_PI*Const::hbar/Const::pas_x/(1.*Const::n_x);	}	cout<<"Enregistrement imp: "+to_string(j)<<endl;}void enregistref(vector<Complex> & psi, unsigned int j){	ofstream flux("../resultat_temp/psi"+to_string(j)+".txt");	flux<<"t="<<j*Const::pas_t<<" "<<"position"<<" "<<"norme"<<" "<<"phase"<<endl;	for(unsigned int i=0; i<Const::n_x; i++){		flux<<2.*M_PI*Const::hbar/Const::pas_x/Const::n_x*i<<" "<<psi[i].get_norme()<<" "<<psi[i].get_phase()<<endl;	}	cout<<"Enregistrement imp: "+to_string(j)<<endl;}double integrate(list<Complex> & psi){	list<Complex>::iterator it;	double S = 0;	for(it = psi.begin(); it!=psi.end(); it++){		S+=pow((*it).get_norme(),2);	}	return S*Const::pas_x;}void moment(list<Complex> & psi, unsigned int j){	if(j==0){		ofstream flux("../resultat_temp/moment.txt");		flux<<"Temps"<<" "<<"Norme"<<" "<<"Centre"<<" "<<"Ecart"<<endl;	}	else{		ofstream flux("../resultat_temp/moment.txt", ios::app);	}	list<Complex>::iterator it = psi.begin();	double S0 = 0;	double S1 = 0;	double S2 = 0;	for(unsigned int i=0; i<Const::n_x; i++){		S0+=pow((*it).get_norme(),2);		S1+=pow((*it).get_norme(),2)*(Const::min_x + i*Const::pas_x);		S2+=pow((*it).get_norme(),2)*pow(Const::min_x + i*Const::pas_x,2);		it++;	}	ofstream flux("../resultat_temp/moment.txt", ios::app);	flux<<j*Const::pas_t<<" "<<S0*Const::pas_x<<" "<<S1*Const::pas_x<<" "<<pow(S2*Const::pas_x-pow(S1*Const::pas_x, 2), 0.5)<<endl;}void moment(vector<Complex> & psi, unsigned int j){	if(j==0){		ofstream flux("../resultat_temp/momentB.txt");		flux<<"Temps"<<" "<<"Norme"<<" "<<"Centre"<<" "<<"Ecart"<<endl;	}	else{		ofstream flux("../resultat_temp/momentB.txt", ios::app);	}	double S0 = 0;	double S1 = 0;	double S2 = 0;	for(unsigned int i=0; i<Const::n_x; i++){		S0+=pow(psi[i].get_norme(),2);		S1+=pow(psi[i].get_norme(),2)*(Const::min_x + i*Const::pas_x);		S2+=pow(psi[i].get_norme(),2)*pow(Const::min_x + i*Const::pas_x,2);	}	ofstream flux("../resultat_temp/momentB.txt", ios::app);	flux<<j*Const::pas_t<<" "<<S0*Const::pas_x<<" "<<S1*Const::pas_x<<" "<<pow(S2*Const::pas_x-pow(S1*Const::pas_x, 2), 0.5)<<endl;}void affinfo(double x0, double p0, double s0, double V0){	double pmax = Const::hbar*M_PI/Const::pas_x;//Impulsion maximal imposée par la critère de Shannon-Nyquist	cout<<"Le pas spatial est: "<<Const::pas_x<<" fm"<<endl;	cout<<"La simulation s'effectue sur la plage spatiale ["<<Const::min_x<<";"<<Const::max_x<<"] fm"<<endl;	cout<<"Le pas temporel est: "<<Const::pas_t<<" fm/c"<<endl;	cout<<"La simulation s'effectue sur la plage temporelle [0;"<<Const::pas_t*Const::n_t<<"] fm/c"<<endl;	if(abs(p0)<pmax){		cout<<"Le critère de Shanon |"<<p0<<"|<"<<pmax<<" MeV/c est rempli"<<endl;	}	else{		cout<<"ATTENTION : Le critère de Shanon |<"<<p0<<"|"<<pmax<<" MeV/c n'est pas rempli"<<endl;	}	cout<<"L'énergie totale vaut: "<<p0*p0/2./Const::m+V0<<" MeV"<<endl;}void dpds(double p0, PotOH V, vector<Complex> & psi, unsigned int j){	if(j==0){		ofstream flux("../resultat_temp/dpds.txt");		flux<<"dp"<<" "<<"sigma"<<endl;	}	else{		ofstream flux("../resultat_temp/dpds.txt", ios::app);	}	double S0 = 0;	double S1 = 0;	double S2 = 0;	for(unsigned int i=0; i<Const::n_x; i++){		S0+=pow(psi[i].get_norme(),2);		S1+=pow(psi[i].get_norme(),2)*(Const::min_x + i*Const::pas_x);		S2+=pow(psi[i].get_norme(),2)*pow(Const::min_x + i*Const::pas_x,2);	}	double sigma = pow(S2*Const::pas_x-pow(S1*Const::pas_x, 2), 0.5);	double p1 = pow(2*Const::m*V(S1-sigma/2., 0.), 0.5);	double p2 = pow(2*Const::m*V(S1+sigma/2., 0.), 0.5);	ofstream flux("../resultat_temp/dpds.txt", ios::app);	flux<<abs(p2-p1)/2.<<" "<<sigma<<endl;}void proba_fission(vector<Complex> & psi, unsigned int j, double wall){	if(j==0){		ofstream flux("../resultat_temp/proba.txt");		flux<<"Temps"<<" "<<"Proba"<<endl;	}	else{		ofstream flux("../resultat_temp/proba.txt", ios::app);	}	double S0 = 0;	for(unsigned int i=0; i<Const::n_x; i++){		if(Const::min_x+i*Const::pas_x < wall){			S0+=pow(psi[i].get_norme(),2);		}	}	ofstream flux("../resultat_temp/proba.txt", ios::app);	flux<<j*Const::pas_t<<" "<<1-S0*Const::pas_x<<endl;}void saveaction(vector<Complex> & psi, unsigned int j, double phimax){	ofstream flux("../resultat_temp/act"+to_string(j)+".txt");	flux<<"t="<<j*Const::pas_t<<" "<<"position"<<" "<<"action"<<endl;	vector<double> act(Const::n_x, 0.);	for(unsigned int i=0; i<Const::n_x; i++){		act[i] = psi[i].get_phase();	}	for(unsigned int i=0; i<Const::n_x-1; i++){		if(act[i+1]-act[i]>=phimax){			for(unsigned int j=i+1; j<Const::n_x; j++){				act[j]=act[j]-2.*M_PI;			}		}		if(act[i+1]-act[i]<=-phimax){			for(unsigned int j=i+1; j<Const::n_x; j++){				act[j]=act[j]+2.*M_PI;			}		}		flux<<1.*Const::min_x+1.*i*Const::pas_x<<" "<<act[i]*Const::hbar<<endl;	}	cout<<"Enregistrement act: "+to_string(j)<<endl;}double action(vector<Complex> & psi, int j, double phimax){	if(j<0 || j>=Const::n_x){		return 0;	}	unsigned int nombre = 0;	for(unsigned int i=0; i<=j; i++){		if(psi[i+1].get_phase()-psi[i].get_phase()>phimax){			nombre--;		}		if(psi[i+1].get_phase()-psi[i].get_phase()<-phimax){			nombre++;		}	}	return (psi[j].get_phase()-nombre*2.*M_PI)*Const::hbar;}void savetraj(vector<double> & pos, vector<double> & vit, vector<double> & veff, unsigned int j){	ofstream flux("../resultat_temp/trajB"+to_string(j)+".txt");	flux<<"t="<<j*Const::pas_t<<" position vitesse potentiel"<<endl;	for(unsigned int i=0; i<Const::n_pt; i++){		flux<<pos[i]<<" "<<vit[i]<<" "<<veff[i]<<endl;	}}double calc_Q(vector<Complex> & psi, int j){	if(j==0){		return calc_Q(psi, 1);	}	else if(j==Const::n_x-1){		return calc_Q(psi, Const::n_x-2);	}	else if(j<0 || j>Const::n_x){		return 0;	}	else{		if(psi[j].get_norme()==0){			return 0;		}		else{			//return -Const::hbar*Const::hbar/2./Const::m/psi[j].get_norme()*(psi[j+1].get_norme()+psi[j-1].get_norme()-2*psi[j].get_norme())/Const::pas_x/Const::pas_x;			return -Const::hbar*Const::hbar/2./Const::m*((log(psi[j+1].get_norme())+log(psi[j-1].get_norme())-2*log(psi[j].get_norme()))+0.25*pow((log(psi[j+1].get_norme())-log(psi[j-1].get_norme())), 2.))/Const::pas_x/Const::pas_x;		}	}}double calc_gradS(vector<Complex> & psi, unsigned int j){	if(j<=0){		return calc_gradS(psi, 1);	}	else if(j>=Const::n_x-1){		return calc_gradS(psi, Const::n_x-2);	}	else{		if(psi[j+1].get_phase()-psi[j].get_phase()>M_PI){			return (psi[j+1].get_phase()-psi[j].get_phase()-2*M_PI)*Const::hbar/Const::pas_x;		}		else if(psi[j+1].get_phase()-psi[j].get_phase()<-M_PI){			return (psi[j+1].get_phase()-psi[j].get_phase()+2*M_PI)*Const::hbar/Const::pas_x;			}		else{			return (psi[j+1].get_phase()-psi[j].get_phase())*Const::hbar/Const::pas_x;		}	}}void saveVeff(vector<double> & veffl, unsigned int j){	if(j==0){		ofstream flux("../resultat_temp/pot.txt");	}	else{		ofstream flux("../resultat_temp/pot.txt", ios::app);	}	ofstream flux("../resultat_temp/pot.txt", ios::app);	for(unsigned int i=0; i<Const::n_x; i++){		flux<<veffl[i]<<" ";	}	flux<<endl;}int main(){	/*	list<Complex> fx;	list<Complex> fk;	Gaussian psi0(0, 0, 0.02);//4823.78, 0.08	PotConst pot(1);	for(int i=0; i<Const::n_x; i++){		fx.push_back(psi0(Const::min_x+i*Const::pas_x));		fk.push_back(Complex(0,0));		//enregistre(fx, 0);	}	for(int j=0; j<Const::n_t; j++){		if(j%100==0){			cout<<j<<endl;			enregistre(fx, j);			moment(fx, j);		}		list<Complex>::iterator it = fx.begin();		for(unsigned int i = 0; i<Const::n_x; i++){			*it = *it * Complex::cexp(1, -pot(Const::min_x+i*Const::pas_x, 0)*Const::pas_t/2/Const::hbar);			it++;			//enregistre(fx, 1);		}		fourier(fx, fk);		//enregistref(fk, 2);		it = fk.begin();		for(unsigned int i = 0; i<Const::n_x; i++){			*it = *it * Complex::cexp(1, -pow((i-Const::n_x/2.)*2.*M_PI*Const::hbar/Const::pas_x/Const::n_x,2)*Const::pas_t/2/Const::m/Const::hbar);			//cout<<pow(i*2.*M_PI*Const::hbar/Const::pas_x/Const::n_x,2.)*Const::pas_t/2/Const::m/Const::hbar<<endl;			it++;			//enregistref(fk, 3);			//moment(fk, 0);		}		ifourier(fk, fx);		it = fx.begin();		for(unsigned int i = 0; i<Const::n_x; i++){			*it = *it * Complex::cexp(1, -pot(Const::min_x+i*Const::pas_x, 0)*Const::pas_t/2/Const::hbar);			it++;			//enregistre(fx, 4);		}		if(j%100==0){			enregistref(fk, j);			moment(fk, j);		}				if(j%1==0){			enregistre(fx, j);			moment(fx, j);		}				//fourier(fx, fk);		//enregistref(fk, j);		//moment(fk, j);		//if(j%1==0){		//	enregistref(fk, j);			//moment(fx, j);		//}	}*/	//Potentiel constant	/*	double x0 = 0.;	double p0 = 50.;	double s0 = 3.;	*/	//Double gaussienne	double x0 = -35.;	double p0 = 0.;	double s0 = 2.;	s0 = s0/0.89799438;	//OH	/*double x0 = 5.;	double p0 = 0.;	double s0 = 10.;*/	//WS	/*	double x0=0.;	double p0=150.;	double s0=1.;	*/	//PotConst pot(0.);	//PotOH pot(0.005);//p0/Const::m/20.	PotFis pot(-70., -30., 10., 70., 1000., 1000.);	//PotWS pot(50., 0.5);	PotAbs pot2(40., 100.);	//PotConst pot2(0.);	//PotDAbs pot2(40., 1000.);	//double x0 = 5.;	//double p0 = 0.;	//double s0 = 5.;	//PotQuart pot(0, 1./100000.);	Gaussian psi0(x0, p0, s0);//4823.78, 0.08	affinfo(x0, p0, s0, pot(x0, 0));	vector<Complex> ffx(Const::n_x, Complex(0, 0));	vector<Complex> ffk(Const::n_x, Complex(0, 0));		vector<double> rho(Const::n_x, 0);	vector<double> logrho(Const::n_x, 0);	for(int i=0; i<Const::n_x; i++){		ffx[i] = psi0(Const::min_x*1.+1.*i*Const::pas_x);	}	vector<double> pos(Const::n_pt, 0);	vector<double> vit(Const::n_pt, p0/Const::m);	vector<double> veff(Const::n_pt, 0);	vector<double> veffl(Const::n_x, 0);	int N = (Const::n_pt-1)/2;	pos[N] = x0;	for(unsigned int i=1; i<=N; i++){		double f = 1./(pow(psi0(pos[N-i+1]).get_norme(), 2)*Const::n_pt);		pos[N-i] = pos[N-i+1]-f;		pos[N+i] = 2*x0-pos[N-i];	}	for(unsigned int j=0; j<Const::n_t; j++){		/*		if(j%100==0){			moment(ffx, j);			//proba_fission(ffx, j, -25.);			//saveaction(ffx, j, M_PI);			//dpds(p0, pot, ffx, j);			savetraj(pos, vit, veff, j);			//cout<<j<<endl;		}		*/		if(j%100 == 0){			//enregistre(ffx, j);			savetraj(pos, vit, veff, j);			//proba_fission(ffx, j, -20.);			moment(ffx, j);			vector<double> Q(Const::n_x, 0);			//for(unsigned int i=0; i<Const::n_x; i++){			//	Q[i] = calc_Q(ffx, i);			//	rho[i] = pow(ffx[i].get_norme(), 2);			//	logrho[i] = log(rho[i]);			//}			//vector<Complex> fQ(Const::n_x, Complex(0, 0));			//fft(Q, fQ);			//enregistre(logrho, j);			//enregistref(fQ, j+1);			//enregistre(logrho, j+1);			cout<<j<<endl;		}		/*		for(unsigned int i=0; i<Const::n_x; i++){			double x = Const::min_x+i*Const::pas_x;			ffx[i] = ffx[i]*Complex::cexp(1., -Const::pas_t/2./Const::hbar*pot(x, 0));		}		fft(ffx, ffk);		for(int i=0; i<Const::n_x; i++){			double p = (i*1.-Const::n_x/2.)*2.*M_PI*Const::hbar/(Const::n_x*1.)/Const::pas_x;			ffk[i] = ffk[i]*Complex::cexp(1., -p*p/2./Const::m/Const::hbar*Const::pas_t);		}				if(j%10 == 0){			enregistref(ffk, j);			moment(ffk, j);		}				ifft(ffk, ffx);		for(unsigned int i=0; i<Const::n_x; i++){			double x = Const::min_x+i*Const::pas_x;			ffx[i] = ffx[i]*Complex::cexp(1., -Const::pas_t/2./Const::hbar*pot(x, 0));		}		if(j%100==0){			moment(ffx, j);		}		if(j%1000 == 0){			enregistre(ffx, j);			cout<<j<<endl;		}		*/		fft(ffx, ffk);		//if(j%100 == 0){		//	enregistre(ffx, j+2);		//	enregistref(ffk, j+1);		//}		for(int i=0; i<Const::n_x; i++){			double p = (i*1.-Const::n_x/2.)*2.*M_PI*Const::hbar/(Const::n_x*1.)/Const::pas_x;			ffk[i] = ffk[i]*Complex::cexp(1., -p*p/4./Const::m/Const::hbar*Const::pas_t);		}		ifft(ffk, ffx);		for(unsigned int i=0; i<Const::n_x; i++){			double x = Const::min_x+i*Const::pas_x;			ffx[i] = ffx[i]*Complex::cexp(exp(-pot2(x, 0)*Const::pas_t/Const::hbar), -Const::pas_t/Const::hbar*pot(x, 0));		}		fft(ffx, ffk);		for(unsigned int i=0; i<Const::n_x; i++){			double p = (i*1.-Const::n_x/2.)*2.*M_PI*Const::hbar/(Const::n_x*1.)/Const::pas_x;			ffk[i] = ffk[i]*Complex::cexp(1., -p*p/4./Const::m/Const::hbar*Const::pas_t);		}		ifft(ffk, ffx);		//Méthode 1 : v=grad(S)/m		/*		for(unsigned int i=0; i<Const::n_pt; i++){			int j = floor((pos[i]-Const::min_x)/Const::pas_x);			if(j>=0 && j<Const::n_x-1){				vit[i] = interpolationl1D(Const::min_x+j*Const::pas_x, Const::min_x+(j+1.)*Const::pas_x, calc_gradS(ffx, j), calc_gradS(ffx, j+1), pos[i])/Const::m;				veff[i] = interpolationl1D(Const::min_x+j*Const::pas_x, Const::min_x+(j+1.)*Const::pas_x, calc_Q(ffx, j), calc_Q(ffx, j+1), pos[i])+pot(pos[i], 0);			}			pos[i] += vit[i]*Const::pas_t;		}		if(j%((Const::n_t-1)/500)==0){			for(unsigned int i=0; i<Const::n_x; i++){				veffl[i] = calc_Q(ffx, i)+pot(Const::min_x+i*Const::pas_x, 0);			}			saveVeff(veffl, j);		}*/		//Méthode 2 : dv/dt=-grad(Veff)/m		for(unsigned int i=0; i<Const::n_x; i++){			veffl[i] = calc_Q(ffx, i)+pot(Const::min_x+i*Const::pas_x, 0);			//veffl[i] = pot(Const::min_x+i*Const::pas_x, 0);		}		if(j%100 == 0){			saveVeff(veffl, j);		}		for(unsigned int i=0; i<Const::n_pt; i++){			int k = floor((pos[i]-Const::min_x)/Const::pas_x);			if(pos[i]>-50. and pos[i]<40.){				double v = vit[i];				vit[i] += -interpolationl1D(Const::min_x+k*Const::pas_x, Const::min_x+(k+1.)*Const::pas_x, gradient1D(veffl, k), gradient1D(veffl, k+1), pos[i])*Const::pas_t/Const::m;				veff[i] = interpolationl1D(Const::min_x+k*Const::pas_x, Const::min_x+(k+1.)*Const::pas_x, calc_Q(ffx, k), calc_Q(ffx, k+1), pos[i])+pot(pos[i], 0);				pos[i] += v*Const::pas_t;			}			else{				vit[i]=0;			}		}	}	return 0;}