#include<iostream>#include<fstream>#include<list>#include<vector>#include<string>#include<cmath>#include<cstdlib>#include<ctime>#include<algorithm>#include<iomanip>using namespace std;#include "const.h"#include "complex.h"#include "potential.h"#include "initial.h"#include "opemath.h"#include "save.h"#include "fourier.h"#include "poly.h"int prog = 0;vector<double> calc_rho_d(vector<double> x, double x0){//Calcul les dérivés 0, 1 et 2 de rho en x0.	vector<double> res(3, 0);	double norme = pow((2*M_PI*pow(Const::eta, 2)), -0.5)/Const::n_x;	for(unsigned int i=0; i<x.size(); i++){		double xi = (x[i]-x0)/(pow(2., 0.5)*Const::eta);		res[0] += norme*exp(-pow(xi, 2))*(3./2.-pow(xi, 2));		res[1] += norme*exp(-pow(xi, 2))*(-5.*xi+2.*pow(xi, 3));		res[2] += norme*exp(-pow(xi, 2))*(-5.+16.*pow(xi, 2)-4.*pow(xi, 4));	}	return res;}double calc_R(vector<double> x, double x0){//Calcul rho en x0.	if(x0<x[0] || x0>x[x.size()-1]){		return 0;	}	double res = 0;	double norme = pow((2*M_PI*pow(Const::eta, 2)), -0.5)/Const::n_x;	for(unsigned int i=0; i<x.size(); i++){		double xi = (x[i]-x0)/(pow(2., 0.5)*Const::eta);		res += norme*exp(-pow(xi, 2))*(3./2.-pow(xi, 2));	}	return pow(abs(res), 0.5);}int main(){	if(prog==0){		double x0 = 0.;//fm		double p0 = 0.;//MeV/c		double s0 = 2.;//fm		//s0 = s0/0.89799438;//Pour N=33		//s0 = s0*2./1.89173;//Pour N=101		//s0 = s0*2./1.83925;//Pour N=51		//s0 = s0*2./1.7418;//Pour N=21		//s0 = s0*2./1.92901;//Pour N=201		Gaussian psi0(x0, p0, s0);		double w = 0.005;//c/fm				//double E0 = 0.;		//double ome = 0.;				//PotConst pot(0);		PotOH pot(w);		//PotFis pot(-70., -30., 10., 70., 1000., 1000.);		//PotQuart pot(0.05, 1./10000.);		//PotWS pot(100., 1.);				//vector<double> xb;		vector<double> x(Const::n_x, 0);		vector<double> v(Const::n_x, p0/Const::m);		vector<double> S(Const::n_x, 0);		vector<double> S0(Const::n_x, 0);		vector<double> R0(Const::n_x, 0);		vector<double> tact(Const::n_t, 0);		vector<Complex> correl(Const::n_t, Complex(0, 0));		/*		xb.push_back(pow(Const::hbar/Const::m/w, 0.5));		double N = (Const::n_x-1)/2;		while(xb[xb.size()-1]>0){			double vxc = xb[xb.size()-1];			xb.push_back(vxc-1./(Const::n_x*pow(4./M_PI*pow(Const::m*w/Const::hbar, 3), 0.5)*pow(vxc, 2)*exp(-Const::m*w/Const::hbar*pow(vxc, 2))));		}		xb.pop_back();		for(unsigned int i=N-xb.size(); i<N; i++){			x[i] = -xb[i+xb.size()-N];		}		for(int i=N-xb.size()-1; i>=0; i--){			x[i] = x[i+1]-1./(Const::n_x*pow(4./M_PI*pow(Const::m*w/Const::hbar, 3), 0.5)*pow(x[i+1], 2)*exp(-Const::m*w/Const::hbar*pow(x[i+1], 2)));		}		for(unsigned int i=0; i<N; i++){			x[N+i+1] = -x[N-i-1];		}		x[N] = 0;		for(unsigned int i=0; i<x.size(); i++){			cout<<x[i]<<endl;		}		*/		vector<double> tunnel(Const::n_x, 0);		int N = (Const::n_x-1)/2;		x[N] = x0;		for(unsigned int i=1; i<=N; i++){			double f = 1./(pow(psi0(x[N-i+1]).get_norme(), 2)*(Const::n_x));			x[N-i] = x[N-i+1]-f;			x[N+i] = 2*x0-x[N-i];		}		for(unsigned int i=0; i<Const::n_x; i++){			S[i] = p0*(x[i]-x0);			S0[i] = S[i];		}		for(unsigned int i=1; i<Const::n_x; i++){			R0[i] = pow((x[i]-x[i-1])/(Const::n_x*1.), -0.5);		}		correl[0] = Complex(1., 0);		tact[0] = 0;		double M0 = 0;		double M1 = 0;		double M2 = 0;		double VM = 0;		for(unsigned int i=0; i<Const::n_x; i++){			M0+=1./Const::n_x;			M1+=x[i]/Const::n_x;			M2+=pow(x[i],2)/Const::n_x;			VM+=pot(x[i], 0)/Const::n_x;		}		cout<<M0<<" "<<M1<<" "<<pow(M2-pow(M1, 2), 0.5)<<" "<<VM<<endl;				double ft = 0;		for(unsigned int t=1; t<Const::n_t; t++){			vector<double> fQ(Const::n_x);			vector<double> Q(Const::n_x);			vector<double> Q2(Const::n_x);			for(unsigned int i=0; i<Const::n_x; i++){				double di = ((i>0)?(1./(x[i]-x[i-1])):0);				double dim1 = ((i>1)?(1./(x[i-1]-x[i-2])):0);				double dip1 = ((i<Const::n_x-1)?(1./(x[i+1]-x[i])):0);				double dip2 = ((i<Const::n_x-2)?(1./(x[i+2]-x[i+1])):0);				fQ[i] = pow(Const::hbar, 2)/4./Const::m*(pow(dip1,2)*(1*dip2-2*dip1+1*di)-pow(di,2)*(1*dip1-2*di+1*dim1));				Q[i] = pow(Const::hbar, 2)/8./Const::m*pow(dip1-di, 2);				Q2[i] = -pow(Const::hbar, 2)/4./Const::m*(dip2*dip1-dip1*dip1-dip1*di+di*di-0.5*pow(dip1-di, 2));			}			double Kt=0;			double Qt=0;			double Vt=0;			vector<double> Ei(Const::n_x, 0);			for(unsigned int i=0; i<Const::n_x; i++){				double a = (fQ[i]-pot.deriv(x[i], 0))/Const::m-(v[i]*Const::pas_t/Const::tau);//+E0*cos(ome*t*Const::pas_t);				v[i] += a*Const::pas_t;				if(x[i]<-20 && x[i]+v[i]*Const::pas_t>=-20){					ft+=1./Const::n_x;					tunnel[i] = t*Const::pas_t;				}				x[i] += v[i]*Const::pas_t;				Qt += Q[i]/Const::n_x;				Kt += 0.5*Const::m*pow(v[i], 2)/Const::n_x;				Vt += pot(x[i], 0)/Const::n_x;				Ei[i] = (Q[i]+0.5*Const::m*pow(v[i], 2)+pot(x[i], 0));				S[i] += (0.5*Const::m*pow(v[i], 2)-Q[i]-pot(x[i], 0))*Const::pas_t;			}			double Et = Kt+Qt+Vt;			if((t-1)%100 == 0){				/*				vector<double> rho(Const::n_x, 0);				for(unsigned int i=1; i<Const::n_x; i++){					rho[i] = 1./(Const::n_x*(x[i]-x[i-1]));				}				*/				//save2D(x, rho, t);				/*vector<double> xgrid(1000, 0);				vector<double> rhogrid(1000, 0);				for(unsigned int i=0; i<1000; i++){					xgrid[i] = -50 + i*0.1;					for(unsigned int j=0; j<Const::n_x; j++){						rhogrid[i]+=(2.*M_PI*4)*exp(-pow(xgrid[i]-x[j], 2)/2./4.)/Const::n_x;					}				}				save2D(xgrid, rhogrid, t);				save2D(x, rho, t);				*/				moment(x, t-1);				savetraj(x, v, v, Const::n_x, t-1);				savet(ft, t-1);				//save2D(x, Ei, t);			}			if(t%(Const::n_t/100)==0){				//cout.width(7);				//cout<<setprecision(7);				cout<<t/(Const::n_t/100)<<" "<<t<<" "<<t*Const::pas_t<<" "<<Et<<" = "<<Kt<<" + "<<Vt<<" + "<<Qt<<" ; "<<Et/Const::hbar/0.005<<" "<<ft<<endl;			}			/*			for(unsigned int i=1; i<Const::n_x; i++){				correl[t+1] = correl[t+1]+Complex::cexp(R0[i]*pow((x[i]-x[i-1])/(1.*Const::n_x), -0.5), (S[i]-S0[i])/Const::hbar);			}			tact[t+1] = (t+1)*Const::pas_t;			*/		}		double MB0=0;		double MB1=0;		double MB2=0;		for(unsigned int i=0; i<tunnel.size(); i++){			if(tunnel[i]!=0){				MB0+=1.;				MB1+=tunnel[i];				MB2+=pow(tunnel[i],2);			}		}		cout<<"Information sur la distribution en temps: moyenne <t> = "<<MB1/MB0<<"fm/c ecart type sqrt(<(t-<t>)²>) = "<<pow((MB2/MB0-MB1/MB0*MB1/MB0),0.5)<<" fm/c"<<endl;		M0 = 0;		M1 = 0;		M2 = 0;		for(unsigned int i=0; i<Const::n_x; i++){			M0+=1./Const::n_x;			M1+=x[i]/Const::n_x;			M2+=pow(x[i],2)/Const::n_x;		}		cout<<M0<<" "<<M1<<" "<<pow(M2-pow(M1, 2), 0.5)<<endl;		//Fourier des trajectoires		/*		vector<double> rho(Const::n_x, 0);		for(unsigned int i=1; i<Const::n_x; i++){			rho[i] = 1./(Const::n_x*(x[i]-x[i-1]));		}		vector<Complex> rhow(Const::n_t+2, Complex(0, 0));		vector<Complex> irhot(Const::n_t+2, Complex(0, 0));		for(unsigned int i=0; i<Const::n_t+2; i++){			irhot[i] = Complex(rhot[i], 0);		}		vector<double> nrhow(Const::n_t+2, 0);		vector<double> omega(Const::n_t+2, 0);		double dw = 2*M_PI/(1.*Const::n_t+2.)/Const::pas_t;		rec_fft(irhot, rhow, Const::n_t+2);		for(unsigned int i=0; i<(Const::n_t+2)/2; i++){			omega[i] = (i-(Const::n_t+2)/2.)*dw*Const::hbar;			omega[i+(Const::n_t+2)/2.] = i*dw*Const::hbar;			nrhow[i] = rhow[i+(Const::n_t+2)/2.].get_norme();			nrhow[i+(Const::n_t+2)/2.] = rhow[i].get_norme();		}		for(unsigned int i=0; i<Const::n_t+2; i++){			nrhow[i] = log(nrhow[i]);		}		*/		//cout<<rhow.size()<<endl;		//save2D(tact, rhot, 0);		//save2D(omega, nrhow, 1);		//Autocorrélation		/*		vector<double> tau(Const::n_t/100, 0);		vector<double> autocorrel(Const::n_t/100, 0);		for(unsigned int ta = 0; ta<tau.size(); ta++){			for(unsigned int tb = 0; tb<rhot.size()-ta*100; tb++){				tau[ta] = ta*100*Const::pas_t;				autocorrel[ta]+=rhot[tb]*rhot[tb+ta*100]*Const::pas_t;			}		}		save2D(tau, autocorrel, 0);		*/		/*		vector<Complex> spectre(1000, Complex(0, 0));		vector<double> n_spectre(1000, 0);		vector<double> omega(1000, 0);		double dw = 2.*M_PI/Const::n_t/Const::pas_t;		for(unsigned int i=0; i<1000; i++){			omega[i] = i*dw;			for(unsigned int j=0; j<correl.size(); j++){				spectre[i] = spectre[i]+correl[j]*Complex::cexp(1, -omega[i]*j*Const::pas_t);			}			cout<<i<<endl;		}		for(unsigned int i=0; i<1000; i++){			omega[i]*=Const::hbar;			n_spectre[i]=log(spectre[i].get_norme());		}		save2D(omega, n_spectre, 0);		*/	}	else if(prog==1){		double x01 = -30.;//fm		//double p01 = 0.;//MeV/c		double p01 = 500.;//MeV/c		double s01 = 3.;//fm		Gaussian psi01(x01, p01, s01);				double x02 = 30.;//fm		//double p02 = 0.;//MeV/c		double p02 = -500.;//MeV/c		double s02 = 3.;//fm		Gaussian psi02(x02, p02, s02);				PotConst pot(0);				vector<double> x1(Const::n_x, 0);		vector<double> x2(Const::n_x, 0);		vector<double> v1(Const::n_x, p01/Const::m);		vector<double> v2(Const::n_x, p02/Const::m);				int N = (Const::n_x-1)/2;		x1[N] = x01;		for(unsigned int i=1; i<=N; i++){			double f = 1./(pow(psi01(x1[N-i+1]).get_norme(), 2)*Const::n_x);			x1[N-i] = x1[N-i+1]-f;			x1[N+i] = 2*x01-x1[N-i];		}		x2[N] = x02;		for(unsigned int i=1; i<=N; i++){			double f = 1./(pow(psi02(x2[N-i+1]).get_norme(), 2)*Const::n_x);			x2[N-i] = x2[N-i+1]-f;			x2[N+i] = 2*x02-x2[N-i];		}				vector<double> S1(Const::n_x, 0);		vector<double> S2(Const::n_x, 0);		for(unsigned int i=0; i<Const::n_x; i++){			S1[i] = p01*(x1[i]-x01);		}		for(unsigned int i=0; i<Const::n_x; i++){			S2[i] = p02*(x2[i]-x02);		}				vector<double> x{x01, x02};		vector<double> v{p01/Const::m, p02/Const::m};				for(unsigned int t=0; t<=Const::n_t; t++){			vector<double> fQ1(Const::n_x);			vector<double> Q1(Const::n_x);			for(unsigned int i=0; i<Const::n_x; i++){				double di = ((i>0)?(1./(x1[i]-x1[i-1])):0);				double dim1 = ((i>1)?(1./(x1[i-1]-x1[i-2])):0);				double dip1 = ((i<Const::n_x-1)?(1./(x1[i+1]-x1[i])):0);				double dip2 = ((i<Const::n_x-2)?(1./(x1[i+2]-x1[i+1])):0);				fQ1[i] = pow(Const::hbar, 2)/4./Const::m*(pow(dip1,2)*(1*dip2-2*dip1+1*di)-pow(di,2)*(1*dip1-2*di+1*dim1)/*-di*dip1*(dip2+dim1-dip1-di)*/);				Q1[i] = pow(Const::hbar, 2)/8./Const::m*pow(dip1-di, 2);			}						vector<double> fQ2(Const::n_x);			vector<double> Q2(Const::n_x);			for(unsigned int i=0; i<Const::n_x; i++){				double di = ((i>0)?(1./(x2[i]-x2[i-1])):0);				double dim1 = ((i>1)?(1./(x2[i-1]-x2[i-2])):0);				double dip1 = ((i<Const::n_x-1)?(1./(x2[i+1]-x2[i])):0);				double dip2 = ((i<Const::n_x-2)?(1./(x2[i+2]-x2[i+1])):0);				fQ2[i] = pow(Const::hbar, 2)/4./Const::m*(pow(dip1,2)*(1*dip2-2*dip1+1*di)-pow(di,2)*(1*dip1-2*di+1*dim1)/*-di*dip1*(dip2+dim1-dip1-di)*/);				Q2[i] = pow(Const::hbar, 2)/8./Const::m*pow(dip1-di, 2);			}			/*			vector<double> rho1m = calc_rho_d(x1, x[0]-Const::epsilon);			vector<double> rho1p = calc_rho_d(x1, x[0]+Const::epsilon);			vector<double> rho2m = calc_rho_d(x2, x[1]-Const::epsilon);			vector<double> rho2p = calc_rho_d(x2, x[1]+Const::epsilon);			vector<double> fq(2, 0);			double Q1m = pow(Const::hbar, 2)/4./Const::m*(0.5*pow(rho1m[1]/rho1m[0], 2)-rho1m[2]/rho1m[0]);			double Q1p = pow(Const::hbar, 2)/4./Const::m*(0.5*pow(rho1p[1]/rho1p[0], 2)-rho1p[2]/rho1p[0]);			double Q2m = pow(Const::hbar, 2)/4./Const::m*(0.5*pow(rho2m[1]/rho2m[0], 2)-rho2m[2]/rho2m[0]);			double Q2p = pow(Const::hbar, 2)/4./Const::m*(0.5*pow(rho2p[1]/rho2p[0], 2)-rho2p[2]/rho2p[0]);			fq[0] = (Q1p-Q1m)/2./Const::epsilon;			fq[1] = (Q2p-Q2m)/2./Const::epsilon;			v[0] += fq[0]/Const::m*Const::pas_t;			v[1] += fq[1]/Const::m*Const::pas_t;			x[0] += v[0]*Const::pas_t;			x[1] += v[1]*Const::pas_t;			*/									for(unsigned int i=0; i<Const::n_x; i++){				double a1 = fQ1[i]/Const::m/*-(v[i]*Const::pas_t/Const::tau)*/;//+E0*cos(ome*t*Const::pas_t);				v1[i] += a1*Const::pas_t;				x1[i] += v1[i]*Const::pas_t;				S1[i] += (0.5*Const::m*pow(v1[i], 2)-Q1[i])*Const::pas_t;								double a2 = fQ2[i]/Const::m/*-(v[i]*Const::pas_t/Const::tau)*/;//+E0*cos(ome*t*Const::pas_t);				v2[i] += a2*Const::pas_t;				x2[i] += v2[i]*Const::pas_t;				S2[i] += (0.5*Const::m*pow(v2[i], 2)-Q2[i])*Const::pas_t;			}			/*			vector<double> param1(3, 0);			vector<double> param2(3, 0);			approx_poly(x1, S1, param1);			approx_poly(x2, S2, param2);			#double st1 = s01*pow(1+pow(Const::hbar*t*Const::pas_t/2./Const::m/pow(s01, 2), 2), 0.5);			#double xt1 = x01+p01/Const::m*t*Const::pas_t;			#param1[0] = -p01*xt1+pow(Const::hbar/s01/st1, 2)/8./Const::m*t*Const::pas_t*pow(xt1, 2)+pow(p01, 2)/2./Const::m*t*Const::pas_t-Const::hbar/2.*atan(Const::hbar*t*Const::pas_t/2./Const::m/pow(s01, 2));			#param1[1] = p01-pow(Const::hbar/s01/st1, 2)/Const::m/4.*xt1*t*Const::pas_t;			#param1[2] = pow(Const::hbar/s01/st1, 2)/8./Const::m*t*Const::pas_t;						#double st2 = s02*pow(1+pow(Const::hbar*t*Const::pas_t/2./Const::m/pow(s02, 2), 2), 0.5);			#double xt2 = x02+p02/Const::m*t*Const::pas_t;			#param2[0] = -p02*xt2+pow(Const::hbar/s02/st2, 2)/8./Const::m*t*Const::pas_t*pow(xt2, 2)+pow(p02, 2)/2./Const::m*t*Const::pas_t-Const::hbar/2.*atan(Const::hbar*t*Const::pas_t/2./Const::m/pow(s02, 2));			//param2[1] = p02-pow(Const::hbar/s02/st2, 2)/Const::m/4.*xt2*t*Const::pas_t;			//param2[2] = pow(Const::hbar/s02/st2, 2)/8./Const::m*t*Const::pas_t;			Poly pS1(param1);			Poly pS2(param2);			vector<double> R1(5, 0);			vector<double> R2(5, 0);			for(int i=0; i<5; i++){				double xeps1 = x[0]+(i-2)*Const::epsilon;				R1[i] = (pow(2., -0.5)*(Complex::cexp(calc_R(x1, xeps1), pS1(xeps1))*Complex::cexp(calc_R(x2, x[1]), pS2(x[1]))-Complex::cexp(calc_R(x2, xeps1), pS2(xeps1))*Complex::cexp(calc_R(x1, x[1]), pS1(x[1])))).get_norme();				double xeps2 = x[1]+(i-2)*Const::epsilon;				R2[i] = (pow(2., -0.5)*(Complex::cexp(calc_R(x1, x[0]), pS1(x[0]))*Complex::cexp(calc_R(x2, xeps2), pS2(xeps2))-Complex::cexp(calc_R(x2, x[0]), pS2(x[0]))*Complex::cexp(calc_R(x1, xeps2), pS1(xeps2)))).get_norme();			}			vector<double> fq(2, 0);			double Q1m = ((R1[1]==0)?0:(-pow(Const::hbar, 2)/2./Const::m*(R1[2]+R1[0]-2*R1[1])/R1[1]/pow(Const::epsilon, 2)));			double Q1p = ((R1[3]==0)?0:(-pow(Const::hbar, 2)/2./Const::m*(R1[4]+R1[2]-2*R1[3])/R1[3]/pow(Const::epsilon, 2)));			double Q2m = ((R2[1]==0)?0:(-pow(Const::hbar, 2)/2./Const::m*(R2[2]+R2[0]-2*R2[1])/R2[1]/pow(Const::epsilon, 2)));			double Q2p = ((R2[3]==0)?0:(-pow(Const::hbar, 2)/2./Const::m*(R2[4]+R2[2]-2*R2[3])/R2[3]/pow(Const::epsilon, 2)));			fq[0] = (Q1p-Q1m)/2./Const::epsilon;			fq[1] = (Q2p-Q2m)/2./Const::epsilon;			v[0] += fq[0]/Const::m*Const::pas_t;			v[1] += fq[1]/Const::m*Const::pas_t;			x[0] += v[0]*Const::pas_t;			x[1] += v[1]*Const::pas_t;			*/			vector<double> param1(15, 0);			vector<double> param2(15, 0);			approx_poly(x1, S1, param1);			approx_poly(x2, S2, param2);			/*			double st1 = s01*pow(1+pow(Const::hbar*t*Const::pas_t/2./Const::m/pow(s01, 2), 2), 0.5);			double xt1 = x01+p01/Const::m*t*Const::pas_t;			param1[0] = -p01*xt1+pow(Const::hbar/s01/st1, 2)/8./Const::m*t*Const::pas_t*pow(xt1, 2)+pow(p01, 2)/2./Const::m*t*Const::pas_t-Const::hbar/2.*atan(Const::hbar*t*Const::pas_t/2./Const::m/pow(s01, 2));			param1[1] = p01-pow(Const::hbar/s01/st1, 2)/Const::m/4.*xt1*t*Const::pas_t;			param1[2] = pow(Const::hbar/s01/st1, 2)/8./Const::m*t*Const::pas_t;						double st2 = s02*pow(1+pow(Const::hbar*t*Const::pas_t/2./Const::m/pow(s02, 2), 2), 0.5);			double xt2 = x02+p02/Const::m*t*Const::pas_t;			param2[0] = -p02*xt2+pow(Const::hbar/s02/st2, 2)/8./Const::m*t*Const::pas_t*pow(xt2, 2)+pow(p02, 2)/2./Const::m*t*Const::pas_t-Const::hbar/2.*atan(Const::hbar*t*Const::pas_t/2./Const::m/pow(s02, 2));			param2[1] = p02-pow(Const::hbar/s02/st2, 2)/Const::m/4.*xt2*t*Const::pas_t;			param2[2] = pow(Const::hbar/s02/st2, 2)/8./Const::m*t*Const::pas_t;			*/			Poly pS1(param1);			Poly pS2(param2);			vector<double> R1(7, 0);			vector<double> R2(7, 0);			for(int i=0; i<3; i++){				double xeps1 = x[0]+(i-1)*Const::epsilon;				R1[i] = (pow(2., -0.5)*(Complex::cexp(calc_R(x1, xeps1), pS1(xeps1))*Complex::cexp(calc_R(x2, x[1]), pS2(x[1]))+Complex::cexp(calc_R(x2, xeps1), pS2(xeps1))*Complex::cexp(calc_R(x1, x[1]), pS1(x[1])))).get_phase()*Const::hbar;				double xeps2 = x[1]+(i-1)*Const::epsilon;				R2[i] = (pow(2., -0.5)*(Complex::cexp(calc_R(x1, x[0]), pS1(x[0]))*Complex::cexp(calc_R(x2, xeps2), pS2(xeps2))+Complex::cexp(calc_R(x2, x[0]), pS2(x[0]))*Complex::cexp(calc_R(x1, xeps2), pS1(xeps2)))).get_phase()*Const::hbar;				//double xeps1 = x[0]+(i-1)*Const::epsilon;				//R1[i] = (Complex::cexp(calc_R(x1, xeps1), pS1(xeps1))*Complex::cexp(calc_R(x2, x[1]), pS2(x[1]))).get_phase()*Const::hbar;				//double xeps2 = x[1]+(i-1)*Const::epsilon;				//R2[i] = (Complex::cexp(calc_R(x1, x[0]), pS1(x[0]))*Complex::cexp(calc_R(x2, xeps2), pS2(xeps2))).get_phase()*Const::hbar;			}			//v[0] = (R1[0]-8*R1[1]+8*R1[3]-R1[4])/12./Const::epsilon/Const::m;			//v[1] = (R2[0]-8*R2[1]+8*R2[3]-R2[4])/12./Const::epsilon/Const::m;			/*			if(R1[2]>R1[0]+0.2*M_PI*Const::hbar){				R1[2]+=2*M_PI*Const::hbar;			}			else if(R1[2]<R1[0]-0.2*M_PI*Const::hbar){				R1[2]-=2*M_PI*Const::hbar;			}			if(R2[2]>R2[0]+0.2*M_PI*Const::hbar){				R2[2]+=2*M_PI*Const::hbar;			}			else if(R2[2]<R2[0]-0.2*M_PI*Const::hbar){				R2[2]-=2*M_PI*Const::hbar;			}			*/			v[0] = (-R1[0]+R1[2])/2./Const::epsilon/Const::m;			v[1] = (-R2[0]+R2[2])/2./Const::epsilon/Const::m;			x[0] += v[0]*Const::pas_t;			x[1] += v[1]*Const::pas_t;			if(t%100==0){				/*				vector<double> xgrid(1000, 0);				vector<double> Rgrid(1000, 0);				for(unsigned int i=0; i<1000; i++){					xgrid[i] = -50.+0.1*i;					Rgrid[i] = calc_R(x1, xgrid[i]);				}				vector<double> R1calc(Const::n_x, 0);				for(unsigned int i=1; i<Const::n_x; i++){					R1calc[i] = pow(1./Const::n_x/(x1[i]-x1[i-1]), 0.5);				}				save2D(x1, R1calc, t);				save2D(xgrid, Rgrid, t+1);				*/				savetraj(x1, v1, v1, t, string("A"));				savetraj(x2, v2, v2, t, string("B"));				savetraj(x, v, v, t);				cout<<t<<" "<<t*Const::pas_t<<endl;			}			}	}	return 0;}