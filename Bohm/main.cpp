#include<iostream>#include<fstream>#include<list>#include<vector>#include<string>#include<cmath>#include<cstdlib>#include<ctime>#include <algorithm>using namespace std;#include "const.h"#include "complex.h"#include "potential.h"#include "initial.h"#include "opemath.h"#include "save.h"#include "fourier.h"#include "poly.h"/*double calc_F(vector<double> & gQ, double x){	int j = int((x-Const::min_x)/Const::pas_x);	if(j>=0 and j<Const::n_x-1){		return interpolationl1D(Const::min_x+j*Const::pas_x, Const::min_x+(j+1.)*Const::pas_x, gQ[j], gQ[j+1], x)/Const::m;	}	else{		return 0;	}}*/Poly calc_gradQ(vector<double> & param){	//cout<<param[0]<<" "<<param[1]<<" "<<param[2]<<endl;	Poly lap(param);	Poly grad(param);	lap.deriv();	lap.deriv();	//cout<<lap.get_coeff(0)<<" "<<lap.get_coeff(1)<<" "<<lap.get_coeff(2)<<endl;	grad.deriv();	//cout<<grad.get_coeff(0)<<" "<<grad.get_coeff(1)<<" "<<grad.get_coeff(2)<<endl;	Poly Q = -Const::hbar*Const::hbar/2./Const::m*(lap+(grad)*(grad));	//cout<<Q.get_coeff(0)<<" "<<Q.get_coeff(1)<<" "<<Q.get_coeff(2)<<" "<<Q.get_coeff(3)<<" "<<Q.get_coeff(4)<<" "<<Q.get_coeff(5)<<endl;	Q.deriv();	//cout<<Q.get_coeff(0)<<" "<<Q.get_coeff(1)<<" "<<Q.get_coeff(2)<<" "<<Q.get_coeff(3)<<" "<<Q.get_coeff(4)<<" "<<Q.get_coeff(5)<<endl;	//cout<<endl;	return Q;}Poly calc_Q(vector<double> & param){	//cout<<param[0]<<" "<<param[1]<<" "<<param[2]<<endl;	Poly lap(param);	Poly grad(param);	lap.deriv();	lap.deriv();	//cout<<lap.get_coeff(0)<<" "<<lap.get_coeff(1)<<" "<<lap.get_coeff(2)<<endl;	grad.deriv();	//cout<<grad.get_coeff(0)<<" "<<grad.get_coeff(1)<<" "<<grad.get_coeff(2)<<endl;	Poly Q = -Const::hbar*Const::hbar/2./Const::m*(lap+(grad)*(grad));	//cout<<Q.get_coeff(0)<<" "<<Q.get_coeff(1)<<" "<<Q.get_coeff(2)<<" "<<Q.get_coeff(3)<<" "<<Q.get_coeff(4)<<" "<<Q.get_coeff(5)<<endl;	//cout<<Q.get_coeff(0)<<" "<<Q.get_coeff(1)<<" "<<Q.get_coeff(2)<<" "<<Q.get_coeff(3)<<" "<<Q.get_coeff(4)<<" "<<Q.get_coeff(5)<<endl;	//cout<<endl;	return Q;}double S(double x){	return Const::pas_x*pow(2.*M_PI*Const::sigher*Const::sigher, -1./2.)*exp(-1.*pow(x, 2.))*(3./2.-pow(x, 2));//(15./8.-5./2.*pow(x, 2)+pow(x, 4)/2.);}int main(){	srand48(time(NULL));	//Méthode en dérivant à l'aide de Fourier	/*	//Création de la fonction d'onde initiale	double x0 = 0.;	double p0 = 0.;	double s0 = 3.;	//Création des trajectoires	Gaussian psi0(x0, p0, s0);	vector<double> x(Const::n_pt, 0);	vector<double> v(Const::n_pt, 0);	//Création des observables	double n_tot = 0;	vector<double> R(Const::n_x, 0);	vector<Complex> Rf(Const::n_x, Complex(0, 0));	vector<double> lR(Const::n_x, 0);	vector<double> GQ(Const::n_pt, 0);	//Initialisation	for(unsigned int i=0; i<Const::n_pt; i++){		x[i] = psi0.tirage();		v[i] = p0/Const::m;		int j = int((x[i]-Const::min_x)/Const::pas_x);		if(j>=0 and j<Const::n_x){			R[j]+=1./Const::n_pt;			n_tot++;		}	}	for(unsigned int i=0; i<Const::n_x; i++){		R[i] = pow(R[i], 0.5);	}	//Tri du tableau, qui devrait rester trié	save2D_discret(R, 0);	for(unsigned int k=0; k<Const::n_t; k++){		if(k%100 == 0){			cout<<k<<" "<<n_tot<<endl;			savetraj(x, v, v, 50, k);		}		//On calcule la transformée de Fourier + lissage		fft(R, Rf);//R = sqrt(rho); Rf = TF(R)		filtre(Rf, 1./300.);		//On récupère R lissé		ifft(Rf, R);//R = sqrt(rho) lissé		//Laplacien en fourier		for(unsigned int i=0; i<Const::n_x; i++){			double p = (i*1.-Const::n_x/2.)*2.*M_PI/(Const::n_x*1.)/Const::pas_x;			Rf[i] = -Rf[i]*pow(p, 2);		}		//On récupère le Laplacien		ifft(Rf, lR);//lR = lap(R)		//On détermine Q		for(unsigned int i=0; i<Const::n_x; i++){			//On stocke LapR/R			if(abs(R[i])>1./Const::n_pt){				R[i] = -Const::hbar*Const::hbar * lR[i]/R[i]/2./Const::m;//R = Q			}			else{				R[i] = 0;			}		}		//FFT de Q		fft(R, Rf);//Rf = TF(Q)		//Gradient en Fourier		for(unsigned int i=0; i<Const::n_x; i++){			double p = (i*1.-Const::n_x/2.)*2.*M_PI/(Const::n_x*1.)/Const::pas_x;			Rf[i] = Rf[i]*Complex(0, p);		}		//IFFT pour obtenir grad(Q)		ifft(Rf, R);//R = grad(Q)		//Vieux Euler		for(unsigned int i=0; i<Const::n_pt; i++){			//On calcule grad Q			int j = int((x[i]-Const::min_x)/Const::pas_x);			if(j>=0 and j<Const::n_x-1){				GQ[i] = R[j];//interpolationl1D(Const::min_x+j*Const::pas_x, Const::min_x+(j+1.)*Const::pas_x, R[j], R[j+1], x[i]);			}			else{				GQ[i] = 0;			}					}		for(unsigned int i=0; i<Const::n_pt; i++){			//On fait évoluer les vitesses et position avec rk4			double k1 = calc_F(R, x[i]);			double k2 = calc_F(R, x[i]+Const::pas_t*v[i]/2.);			double k3 = calc_F(R, x[i]+Const::pas_t*v[i]/2.+Const::pas_t*Const::pas_t/4.*k1);			double k4 = calc_F(R, x[i]+Const::pas_t*v[i]+Const::pas_t*Const::pas_t/2.*k2);			x[i] += v[i]*Const::pas_t + Const::pas_t*Const::pas_t/6.*(k1+k2+k3);			v[i] += Const::pas_t/6.*(k1+2.*k2+2.*k3+k4);			//Vieux Euler			v[i] += GQ[i]*Const::pas_t/Const::m;			x[i] += v[i]*Const::pas_t;		}		for(unsigned int i=0; i<Const::n_x; i++){			R[i]=0;		}		n_tot=0;		for(unsigned int i=0; i<Const::n_pt; i++){			//On recalcule la densité			int j = int((x[i]-Const::min_x)/Const::pas_x);			if(j>=0 and j<Const::n_x){				R[j]+=1./Const::n_pt;				n_tot++;			}		}		for(unsigned int i=0; i<Const::n_x; i++){			R[i] = pow(R[i], 0.5);		}	}	save2D_discret(R, 1);									//Idem que précedent mais avec la formule du log		//save2D_discret(R, 0);	//On calcule la transformée de Fourier + lissage		fft(R, Rf);//R = sqrt(rho); Rf = TF(R)		filtre(Rf, 1./300.);		//On récupère R lissé		ifft(Rf, R);//R = sqrt(rho) lissé	save2D_discret(logR, 1);	//Tri du tableau, qui devrait rester trié	for(unsigned int k=0; k<Const::n_t; k++){		vector<double>	gradlogR(Const::n_x, 0);		vector<double>	laplogR(Const::n_x, 0);		vector<double> Q(Const::n_x, 0);		vector<double> gradQ(Const::n_x, 0);		//save2D_discret(R, k);		if(k%10 == 0){			cout<<k<<" "<<n_tot<<endl;			savetraj(x, v, v, 50, k);		}				for(unsigned int i=1; i<Const::n_x-1; i++){			gradlogR[i] = (logR[i+1]-logR[i-1])/2./Const::pas_x;		}		gradlogR[0] = gradlogR[1];		gradlogR[Const::n_x-1] = gradlogR[Const::n_x-2];		save2D_discret(gradlogR, 2);				for(unsigned int i=1; i<Const::n_x-1; i++){			laplogR[i] = (gradlogR[i+1]+gradlogR[i-1]-2.*gradlogR[i])/pow(Const::pas_x, 2.);		}		laplogR[0] = laplogR[1];		laplogR[Const::n_x-1] = laplogR[Const::n_x-2];		save2D_discret(laplogR, 3);				for(unsigned int i=0; i<Const::n_x; i++){			Q[i] = -pow(Const::hbar, 2.)/2./Const::m*(laplogR[i]/2.-pow(gradlogR[i]/2., 2.));		}		save2D_discret(Q, 4);		for(unsigned int i=1; i<Const::n_x-1; i++){			gradQ[i] = (Q[i+1]-Q[i-1])/2./Const::pas_x;		}		gradQ[0] = gradQ[1];		gradQ[Const::n_x-1] = gradQ[Const::n_x-2];		save2D_discret(Q, 5);		for(unsigned int i=0; i<Const::n_x; i++){			R[i]=0;		}		n_tot=0;		for(unsigned int i=0; i<Const::n_pt; i++){			int j = int(trunc((x[i]-Const::min_x)/Const::pas_x));			if(j>=0 and j<Const::n_x-1){				v[i] += -interpolationl1D(Const::min_x+j*Const::pas_x, Const::min_x+(j+1.)*Const::pas_x, gradQ[j], gradQ[j+1], x[j])/Const::m*Const::pas_t;			}			else{				v[i] = 0;			}			x[i] += v[i]*Const::pas_t;			j = int(trunc((x[i]-Const::min_x)/Const::pas_x));			if(j>=0 and j<Const::n_x){				R[j]+=1./Const::n_pt;				n_tot++;			}		}		//On calcule la transformée de Fourier + lissage		fft(R, Rf);//R = sqrt(rho); Rf = TF(R)		filtre(Rf, 1./300.);		//On récupère R lissé		ifft(Rf, R);//R = sqrt(rho) lissé		for(unsigned int i=0; i<Const::n_x; i++){			if(abs(R[i])>1./Const::n_pt){				logR[i] = log10(R[i]);			}			else{				logR[i] = 0;			}		}	}	*/	//save2D_discret(R, 1);					/*			//Calcul de fit		//Calcul des polynomes d'Hermite		//Création de la fonction d'onde initiale	double x0 = 10.;	double p0 = 0.;	double s0 = 5.;	PotOH pot(0.005);	//Double gaussienne	//double x0 = -35.;	//double p0 = 0.;	//double s0 = 2.;		//PotFis pot(-70., -30., 10., 70., 1000., 1000.);	//PotConst pot(0);	//Création des trajectoires	Gaussian psi0(x0, p0, s0);	//DGaussian psi0(x0, s0);	vector<double> x(Const::n_pt, 0);	vector<double> v(Const::n_pt, 0);	double n_tot = 0;	vector<double> R(Const::n_x, 0);	vector<double> logR(Const::n_x, 0);	vector<double> fit(Const::n_x, 0);	//Initialisation	for(unsigned int i=0; i<Const::n_pt; i++){		x[i] = psi0.tirage();		v[i] = p0/Const::m;		int j = int(round((x[i]-Const::min_x)/Const::pas_x));		if(j>=0 and j<Const::n_x){			R[j]+=1./Const::n_pt/Const::pas_x;			n_tot++;		}	}	//vector<double> g(Const::n_pt, 0);	//for(unsigned int i=Const::n_loc; i<Const::n_x-Const::n_loc; i++){	//	g[i] = 0;	//	for(unsigned int j=i-Const::n_loc; j<=i+Const::n_loc; j++){	//		g[i]+=R[j]*S(Const::pas_x*(j+(-1.)*i)*1./pow(2., 1./2.)/Const::sigher);	//	}	//}	for(unsigned int i=0; i<Const::n_x; i++){		if(R[i]>=1./Const::n_pt/Const::pas_x){			logR[i] = log(R[i]);		}		else{			logR[i] = 0;		}	}	vector<double> xp(Const::n_x, 0);	for(unsigned int i=0; i<Const::n_x; i++){		xp[i] = Const::min_x+i*Const::pas_x;	}	vector<double> param(Const::deg, 0);	//save2D_discret(R, 0);	for(unsigned int k=0; k<Const::n_t; k++){		vector<double> param(Const::deg, 0);		vector<double> xb;		vector<double> g;		vector<double> ib;		for(unsigned int i=0; i<Const::n_x; i++){			if(logR[i]!=0){				xb.push_back(xp[i]);				g.push_back(logR[i]);				ib.push_back(i);			}		}		//int Np = 2*Const::n_loc+1;		//vector<vector<double>> params(Const::n_x, vector<double>(Const::deg, 0));		approx_poly(xb, g, param);		//for(unsigned int i=0; i<xb.size(); i++){		//	for(unsigned int j=0; j<Const::deg; j++){		//		params[ib[i]][j] = param[j];		//	}		//}		//if(xb.size()<Np){//Cas ou je n'ai pas assez de points pour faire du local, on fait donc du global		//	approx_poly(xb, g, param);		//	for(unsigned int i=0; i<xb.size(); i++){		//		for(unsigned int j=0; j<Const::deg; j++){		//			params[ib[i]][j] = param[j];		//		}		//	}		//}		//else{//Cas où j'ai assez de points		//	vector<double> xc(Np);		//	vector<double> gc(Np);		//	//Les premiers points seront un fit au (n_loc+1)-ième point non nul, on met un poids sur le premier		//	vector<double> weight(Np);		//	weight[0] = 1000.;		//	for(unsigned int i=1; i<Np; i++){		//		weight[i] = 1.;		//	}		//	for(unsigned int i=0; i<Np; i++){		//		xc[i] = xb[i];		//		gc[i] = g[i];		//	}		//	approx_poly(xc, gc, param, weight);		//	for(unsigned int i=0; i<=ib[Const::n_loc]; i++){		//		for(unsigned int j=0; j<Const::deg; j++){		//			params[i][j] = param[j];		//		}		//	}		//	//Idem pour les derniers		//	for(unsigned int i=0; i<Np; i++){		//		xc[i] = xb[xb.size()-Np+i];		//		gc[i] = g[xb.size()-Np+i];		//	}		//	approx_poly(xc, gc, param);		//	for(unsigned int i=ib[xb.size()-Const::n_loc]; i<Const::n_x; i++){		//		for(unsigned int j=0; j<Const::deg; j++){		//			params[i][j] = param[j];		//		}		//	}		//	//Les autres		//	for(unsigned int l=Const::n_loc+2; l<=xb.size()-Const::n_loc-1; l++){		//		for(unsigned int i=0; i<Np; i++){		//			xc[i] = xb[l-Const::n_loc+i];		//			gc[i] = g[l-Const::n_loc+i];		//		}		//		approx_poly(xc, gc, param);		//		for(unsigned int j=0; j<Const::deg; j++){		//			params[ib[l]][j] = param[j];		//		}		//	}		//}		for(unsigned int i=0; i<Const::n_x; i++){			R[i]=0;		}		n_tot=0;		Poly gradQ = calc_gradQ(param);		for(unsigned int i=0; i<Const::n_pt; i++){			int j = int(round((x[i]-Const::min_x)/Const::pas_x));			if(j>=0 and j<Const::n_x){				v[i] += -gradQ(x[i])/Const::m*Const::pas_t-pot.deriv(x[i], 0)/Const::m*Const::pas_t;				x[i] += v[i]*Const::pas_t;			}			else if(j<0){				v[i] += -gradQ(x[i])/Const::m*Const::pas_t-pot.deriv(x[i], 0)/Const::m*Const::pas_t;				x[i] += v[i]*Const::pas_t;			}			else{				v[i] += -gradQ(x[i])/Const::m*Const::pas_t-pot.deriv(x[i], 0)/Const::m*Const::pas_t;				x[i] += v[i]*Const::pas_t;			}			j = int(round((x[i]-Const::min_x)/Const::pas_x));			if(j>=0 and j<Const::n_x){				R[j]+=1./Const::n_pt/Const::pas_x;				n_tot++;			}		}		for(unsigned int i=0; i<Const::n_x; i++){			if(R[i]>=1./Const::n_pt/Const::pas_x){				logR[i] = log(R[i]);			}			else{				logR[i] = 0;			}		}		if(k%100 == 0){			savetraj(x, v, v, 50, k);			moment(R, k);			for(unsigned int i=0; i<Const::n_x; i++){				fit[i] = 0;				for(unsigned int j=0; j<Const::deg; j++){					fit[i]+=param[j]*pow(xp[i], j);				}			}			vector<double> Q(Const::n_x, 0);			for(unsigned int i=0; i<Const::n_x; i++){				Q[i] = calc_Q(param)(Const::min_x+i*Const::pas_x);			}			//save2D_discret(R, k);			//save2D_discret(logR, k+1);			//save2D_discret(fit, k+2);			//save2D_discret(Q, k+3);		}		if(k%1000 == 0){			cout<<k<<" "<<n_tot<<" "<<Const::pas_t*k<<endl;			saveVeff(&pot, param, k);		}	}			*/	/*	//DAF	double x0 = 10.;	double p0 = 0.;	double s0 = 5.;	PotOH pot(0.05);	//Création des trajectoires	Gaussian psi0(x0, p0, s0);	vector<double> x(Const::n_pt, 0);	vector<double> v(Const::n_pt, 0);	//Création des observables	double n_tot = 0;	vector<double> R(Const::n_x, 0);	//Initialisation	for(unsigned int i=0; i<Const::n_pt; i++){		x[i] = psi0.tirage();		v[i] = p0/Const::m;		int j = int(round((x[i]-Const::min_x)/Const::pas_x));		if(j>=0 and j<Const::n_x){			R[j]+=1./Const::n_pt/Const::pas_x;			n_tot++;		}	}	//Calcul des polynomes d'Hermite	vector<Poly> Hermite(Const::deg+2);	vector<double> poly0(1, 0);	poly0[0] = 1.;	vector<double> poly1(2, 0);	poly1[1] = 2.;	Hermite[0] = Poly(poly0);	Hermite[1] = Poly(poly1);	for(unsigned int i=2; i<Const::deg+2; i++){		Hermite[i] = Hermite[1]*Hermite[i-1] - (2.*(i-1))*Hermite[i-2];	}		for(unsigned int i=0; i<Const::deg+2; i++){		for(unsigned int j=0; j<Const::deg+2; j++){			cout<<Hermite[i].get_coeff(j)<<" ";		}		cout<<endl;	}	vector<vector<double>> herm_x(Const::deg+2, vector<double>(Const::n_loc*2+1, 0));	for(unsigned int i=0; i<Const::deg+2; i++){		for(unsigned int j=0; j<Const::n_loc*2+1; j++){			herm_x[i][j] = Hermite[i](Const::pas_x*(1.*j+(-1.)*Const::n_loc)/pow(2., 0.5)/Const::sigher);		}	}	//save2D_discret(R, 0);	for(unsigned int t=0; t<Const::n_t; t++){		vector<double> Rs(Const::n_x, 0);		vector<double> lapR(Const::n_x, 0);		vector<double> Q(Const::n_x, 0);		vector<double> gradQ(Const::n_x, 0);		for(unsigned int i=Const::n_loc; i<Const::n_x-Const::n_loc; i++){			for(unsigned int j=i-Const::n_loc; j<=i+Const::n_loc; j++){				for(unsigned int k=0; k<=(Const::deg-1)/2; k++){					Rs[i]+=pow(-1, k)/pow(4., k)/factorial(k)*herm_x[2*k][1.*j+(-1.)*i+Const::n_loc]*pow(R[j], 0.5)*exp(-pow(Const::pas_x*(1.*i+(-1.)*j)/pow(2., 0.5)/Const::sigher, 2.));					lapR[i]+=pow(-1, k)/pow(4., k)/factorial(k)*herm_x[2*k+2][1.*j+(-1.)*i+Const::n_loc]*pow(R[j], 0.5)*exp(-pow(Const::pas_x*(1.*i+(-1.)*j)/pow(2., 0.5)/Const::sigher, 2.));				}			}			Q[i] = -Const::hbar*Const::hbar/2./Const::m * lapR[i]/Rs[i];		}		for(unsigned int i=Const::n_loc; i<Const::n_x-Const::n_loc; i++){			for(unsigned int j=i-Const::n_loc; j<=i+Const::n_loc; j++){				for(unsigned int k=0; k<=(Const::deg-1)/2; k++){					gradQ[i]+=1./pow(2*M_PI*Const::sigher*Const::sigher, 0.5)*pow(-1, k)/pow(4., k)/factorial(k)*herm_x[2*k+1][1.*j+(-1.)*i+Const::n_loc]*Q[j]*exp(-pow(Const::pas_x*(1.*i+(-1.)*j)/pow(2., 0.5)/Const::sigher, 2.));				}			}		}		for(unsigned int i=0; i<Const::n_x; i++){			R[i] = 0;		}		n_tot=0;		for(unsigned int i=0; i<Const::n_pt; i++){			int j = int(round((x[i]-Const::min_x)/Const::pas_x));			if(j>=1 and j<Const::n_x-1){				if(isnormal(interpolationl1D(Const::min_x+(j-1)*Const::pas_x, Const::min_x+(j+1)*Const::pas_x, gradQ[j-1], gradQ[j+1], x[i]))){					v[i]+= -(interpolationl1D(Const::min_x+(j-1)*Const::pas_x, Const::min_x+(j+1)*Const::pas_x, gradQ[j-1], gradQ[j+1], x[i])+pot.deriv(x[i], 0))/Const::m*Const::pas_t;				}				else{					v[i]+= -(gradQ[j]+pot.deriv(x[i], 0))/Const::m*Const::pas_t;				}				x[i]+= v[i]*Const::pas_t;			}			j = int(round((x[i]-Const::min_x)/Const::pas_x));			if(j>=0 and j<Const::n_x){				R[j]+=1./Const::n_pt/Const::pas_x;				n_tot++;			}		}		if(t%100 == 0){			savetraj(x, v, v, 50, t);			cout<<t<<" "<<n_tot<<" "<<Const::pas_t*t<<endl;			save2D_discret(R, t);			//save2D_discret(gradQ, t+50);		}	}	*/		//Calcul de fit	/*	//Calcul des polynomes d'Hermite	vector<Poly> Hermite(Const::degH);	vector<double> poly0(1, 0);	poly0[0] = 1.;	vector<double> poly1(2, 0);	poly1[1] = 2.;	Hermite[0] = Poly(poly0);	Hermite[1] = Poly(poly1);	for(unsigned int i=2; i<Const::degH; i++){		Hermite[i] = Hermite[1]*Hermite[i-1] - (2.*(i-1))*Hermite[i-2];	}		//Création de la fonction d'onde initiale	double x0 = 8.;	double p0 = 0.;	double s0 = 5.;	PotOH pot(0.005);	//Double gaussienne	//double x0 = -35.;	//double p0 = 0.;	//double s0 = 2.;		//PotFis pot(-70., -30., 10., 70., 1000., 1000.);	//PotConst pot(0);	//Création des trajectoires	Gaussian psi0(x0, p0, s0);	//DGaussian psi0(x0, s0);	vector<double> x(Const::n_pt, 0);	vector<double> v(Const::n_pt, 0);	vector<double> R(Const::n_x, 0);	//Création des trajectoires tests	vector<double> xtest(Const::n_test, 0);	vector<double> vtest(Const::n_test, 0);	vector<double> Rtest(Const::n_test, 0);	vector<double> logRtest(Const::n_test, 0); 	//Tableau pour les fits	vector<double> param(Const::deg, 0);	vector<double> dparam(Const::deg, 0);	//Initialisation	for(unsigned int i=0; i<Const::n_pt; i++){		x[i] = psi0.tirage();		v[i] = p0/Const::m;	}	for(unsigned int i=0; i<Const::n_test; i++){		xtest[i] = x0-3.*s0+(6.*s0/(Const::n_test-1.))*i;		vtest[i] = p0/Const::m;	}	//save2D_discret(R, 0);	for(unsigned int k=0; k<Const::n_t; k++){		for(unsigned int i=0; i<Const::n_x; i++){			R[i] = 0;		}		//vector<double> weight(Const::n_test, 0);		if(k%100 == 0){			for(unsigned int i=0; i<Const::n_pt; i++){				for(unsigned int j=0; j<Const::n_test; j++){					for(unsigned int k=0; k<=(Const::degH-1)/2; k++){						if(abs(x[i]-xtest[j])<1000.){							Rtest[j] += pow(-1, k)/pow(4., k)/factorial(k)*Hermite[2*k]((x[i]-xtest[j])/pow(2., 0.5)/Const::sigher)*exp(-pow((x[i]-xtest[j])/pow(2., 0.5)/Const::sigher, 2.));						}					}				}			}		}		vector<double> logRtest_b;		vector<double> xtest_b;		for(unsigned int i=0; i<Rtest.size(); i++){			if(Rtest[i]>0){				logRtest_b.push_back(log(Rtest[i]));				xtest_b.push_back(xtest[i]);			}		}		approx_poly(xtest_b, logRtest_b, param);				Poly gradQ = calc_gradQ(param);		for(unsigned int i=0; i<Const::n_pt; i++){			v[i] += -gradQ(x[i])/Const::m*Const::pas_t-pot.deriv(x[i], 0)/Const::m*Const::pas_t;			x[i] += v[i]*Const::pas_t;			int j = int(round((x[i]-Const::min_x)/Const::pas_x));			if(j>=0 and j<Const::n_x){				R[j]+=1.;			}		}		for(unsigned int i=0; i<Const::n_test; i++){			vtest[i] += -gradQ(xtest[i])/Const::m*Const::pas_t-pot.deriv(xtest[i], 0)/Const::m*Const::pas_t;			xtest[i] += vtest[i]*Const::pas_t;		}		if(k%100 == 0){			savetraj(xtest, vtest, vtest, k);			save2D(xtest, Rtest, k);			save2D(xtest, logRtest, k+1);			vector<double> fit(xtest.size(), 0);			for(unsigned int i=0; i<xtest.size(); i++){				for(unsigned int j=0; j<param.size(); j++){					fit[i] += param[j]*pow(xtest[i], j);				}			}			save2D(xtest, fit, k+2);		}		if(k%1000 == 0){			cout<<k<<" "<<Const::pas_t*k<<endl;			saveVeff(&pot, param, k);			//save2D_discret(R, k);			for(unsigned int i=0; i<Const::deg; i++){				cout<<param[i]<<" ";			}			cout<<endl;		}	}	*/		/*	int N = Const::degfit-1;	vector<vector<int>> bin;	binom(50, bin);		//Grille dynamique + DAF pour calculer gradQ	//Calcul des polynomes d'Hermite	vector<Poly> Hermite(max(Const::degH, Const::deg+2));	vector<double> poly0(1, 0);	poly0[0] = 1.;	vector<double> poly1(2, 0);	poly1[1] = 2.;	Hermite[0] = Poly(poly0);	Hermite[1] = Poly(poly1);	for(unsigned int i=2; i<Const::degH; i++){		Hermite[i] = Hermite[1]*Hermite[i-1] - (2.*(i-1))*Hermite[i-2];	}		//Création de la fonction d'onde initiale	double x0 = 3.;	double p0 = 0.;	double s0 = 5.;	//PotOH pot(0.005);	//Double gaussienne	//double x0 = -35.;	//double p0 = 0.;	//double s0 = 2.;		//PotFis pot(-70., -30., 10., 70., 1000., 1000.);	//PotConst pot(0);	//PotQuart pot(0.01, 1./100000.);	PotQuart pot(0, 1./100000.);	//Création des trajectoires	Gaussian psi0(x0, p0, s0);	//DGaussian psi0(x0, s0);	vector<double> x(Const::n_pt, 0);	vector<double> v(Const::n_pt, 0);	vector<double> R(Const::n_x, 0);	//Création des trajectoires tests	vector<double> xtest(Const::n_test, 0);	vector<double> vtest(Const::n_test, 0);	vector<double> Rtest(Const::n_test, 0);	//Initialisation	for(unsigned int i=0; i<Const::n_pt; i++){		x[i] = psi0.tirage();		v[i] = p0/Const::m;	}	for(unsigned int i=0; i<Const::n_test; i++){		xtest[i] = x0-3.*s0+(6.*s0/(Const::n_test-1.))*i;		vtest[i] = p0/Const::m;	}	//save2D_discret(R, 0);	for(unsigned int t=0; t<Const::n_t; t++){		//On remet R à 0		for(unsigned int i=0; i<Const::n_x; i++){			R[i] = 0;		}		//on calcule tout les 100 pas de temps la valeur de R sur les particules tests		if(t%10 == 0){			for(unsigned int i=0; i<Const::n_test; i++){				Rtest[i]=0;			}			for(unsigned int i=0; i<Const::n_pt; i++){				for(unsigned int j=0; j<Const::n_test; j++){					for(unsigned int k=0; k<=(Const::degH-1)/2; k++){						if(abs(x[i]-xtest[j])<1000.){							Rtest[j] += pow(-1, k)/pow(4., k)/factorial(k)*Hermite[2*k]((x[i]-xtest[j])/pow(2., 0.5)/Const::sigherH)*exp(-pow((x[i]-xtest[j])/pow(2., 0.5)/Const::sigherH, 2.))/Const::n_pt*pow(2.*M_PI*pow(Const::sigherH, 2.), -0.5);						}					}				}			}		}		//On calcule Q par convolution		vector<double> g(Const::n_test, 0);		vector<double> lapg(Const::n_test, 0);		for(unsigned int i=Const::n_loc; i<Const::n_test-Const::n_loc; i++){			for(unsigned int j=i-Const::n_loc; j<=i+Const::n_loc; j++){				for(unsigned int k=0; k<=(Const::deg-1)/2; k++){					g[i]+= pow(-1, k)/pow(4., k)/factorial(k)*Hermite[2*k]((xtest[i]-xtest[j])/pow(2., 0.5)/Const::sigher)*exp(-pow((xtest[i]-xtest[j])/pow(2., 0.5)/Const::sigher, 2.))*pow(2.*M_PI*pow(Const::sigher, 2.), -0.5)*pow(abs(Rtest[j]), 0.5);					lapg[i]+= pow(-1, k)/pow(4., k)/factorial(k)*Hermite[2*k+2]((xtest[i]-xtest[j])/pow(2., 0.5)/Const::sigher)*exp(-pow((xtest[i]-xtest[j])/pow(2., 0.5)/Const::sigher, 2.))*pow(2.*M_PI*pow(Const::sigher, 2.), -0.5)*pow(abs(Rtest[j]), 1.5);				}			}		}		vector<double> Q(Const::n_test, 0);		for(unsigned int i=Const::n_loc; i<Const::n_test-Const::n_loc; i++){			Q[i] = -pow(Const::hbar, 2)/2./Const::m*lapg[i]/g[i];			if(!isnormal(Q[i])){				Q[i]=0;			}		}		//On cherche les extremums de la fonction		vector<double> xextr;		vector<int> iextr;		for(unsigned int i=1; i<Const::n_test-1; i++){			if((Q[i]-Q[i-1])*(Q[i+1]-Q[i])<0){				xextr.push_back(xtest[i]);				iextr.push_back(i);			}		}		vector<double> xinf;		vector<int> iinf;		for(unsigned int i=2; i<Const::n_test-2; i++){			if((Q[i+2]+Q[i]-2*Q[i+1])*(Q[i]+Q[i-2]-2*Q[i-1])<0 and (Q[i]-Q[i-1])*(Q[i+1]-Q[i])>0){				xinf.push_back(xtest[i]);				iinf.push_back(i);			}		}		//On enleve les points qui sont trop sur les bords		while((iextr[0]<Const::n_locfit or xextr[0]<-50) and iextr.size()>1){			xextr.erase(xextr.begin());			iextr.erase(iextr.begin());		}		while((iextr[iextr.size()-1]>Const::n_test-Const::n_locfit-1 or xextr[0]>50) and iextr.size()>1){			xextr.pop_back();			iextr.pop_back();		}		//On enleve les minimas sur les bords		while(iextr.size()>0){			if(Q[iextr[0]]<Q[iextr[0]+1]){				xextr.erase(xextr.begin());				iextr.erase(iextr.begin());			}			else{				break;			}		}		while(iextr.size()>0){			int N = iextr.size()-1;			if(Q[iextr[N]-1]>Q[iextr[N]]){				xextr.pop_back();				iextr.pop_back();			}			else{				break;			}		}		//On enleve les mauvais point d'inflexion		int j=0;		//iextr.clear();		//iextr.push_back(25);		//xextr.clear();		//xextr.push_back(xtest[25]);		vector<double> xextrb(xextr.size(), 0);		vector<double> iextrb(xextr.size(), 0);		vector<double> xextra(xextr.size(), 0);		vector<double> iextra(xextr.size(), 0);		for(unsigned int i=0; i<xinf.size()-1; i++){			while(iinf[i]>iextr[j] and iinf[i+1]>iextr[j] and j<xextr.size()){				j++;			}			if(iinf[i]<iextr[j] and iinf[i+1]>iextr[j]){				iextrb[j] = iinf[i];				xextrb[j] = xinf[i];				iextra[j] = iinf[i+1];				xextra[j] = xinf[i+1];			}		}		for(unsigned int i=0; i<xextr.size(); i++){			cout<<iextr[i]<<" ";		}		cout<<endl;		for(unsigned int i=0; i<xextrb.size(); i++){			cout<<iextrb[i]<<" ";		}		cout<<endl;		for(unsigned int i=0; i<xextra.size(); i++){			cout<<iextra[i]<<" ";		}		cout<<endl;		cout<<endl;		//On fit et on dérive les fits		vector<vector<double>> paramsl(xextr.size(), vector<double>(Const::degfit, 0));		vector<vector<double>> dparamsl(xextr.size(), vector<double>(Const::degfit-1, 0));		vector<vector<double>> paramsr(xextr.size(), vector<double>(Const::degfit, 0));		vector<vector<double>> dparamsr(xextr.size(), vector<double>(Const::degfit-1, 0));		vector<double> xmi(xextr.size()+1, 0);		vector<double> Qmi(xextr.size()+1, 0);		xmi[0] = xtest[iextr[0]-Const::n_locfit];		Qmi[0] = Q[iextr[0]-Const::n_locfit];		xmi[xextr.size()] = xtest[iextr[xextr.size()-1]+Const::n_locfit];		Qmi[xextr.size()] = Q[iextr[xextr.size()-1]+Const::n_locfit];		for(int i=1; i<xextr.size()-1; i++){			if((iextr[i-1]+iextr[i])%2 == 0){				xmi[i] = xtest[(iextr[i-1]+iextr[i])/2];				Qmi[i] = Q[(iextr[i-1]+iextr[i])/2];			}			else{				xmi[i] = interpolationl1D(iextr[i-1], iextr[i], xextr[i-1], xextr[i], (iextr[i-1]+iextr[i])/2.);				Qmi[i] = interpolationl1D(iextr[i-1], iextr[i], Q[iextr[i-1]], Q[iextr[i]], (iextr[i-1]+iextr[i])/2.);			}		}		for(int i=0; i<xextr.size(); i++){			vector<double> xloc(Const::n_locfit*2+1, 0);			vector<double> Qloc(Const::n_locfit*2+1, 0);			for(int j=iextr[i]-Const::n_locfit; j<=iextr[i]+Const::n_locfit; j++){				xloc[j-iextr[i]+Const::n_locfit] = xtest[j];				Qloc[j-iextr[i]+Const::n_locfit] = Q[j];			}			approx_poly(xloc, Qloc, params[i]);			//approx_monome(xextr[i-Const::n_locfit], xextr[i], xextr[i+Const::n_locfit], Q[iextr[i]-Const::n_locfit], Q[iextr[i]], Q[iextr[i]+Const::n_locfit], Const::degfit-1, params[i], bin);			if(i==0){				approx_monome3(xextr[0], xmi[0], Q[iextr[0]], Qmi[0], Const::degfit-1, paramsl[i], bin);			}			else if(i==xextr.size()-1){				approx_monome3(xextr[xextr.size()-1], xmi[xextr.size()], Q[iextr[xextr.size()-1]], Qmi[xextr.size()], Const::degfit-1, paramsr[i], bin);			}			else{				approx_monome3(xextr[i], xmi[i], Q[iextr[i]], Qmi[i], Const::degfit-1, paramsr[i], bin, Qmi[i]>Q[iextr[i]]);				approx_monome3(xextr[i], xmi[i+1], Q[iextr[i]], Qmi[i+1], Const::degfit-1, paramsl[i+1], bin, Qmi[i+1]>Q[iextr[i]]);			}			Poly Pl(paramsl[i]);			Pl.deriv();			Poly Pr(paramsr[i]);			Pr.deriv();			for(unsigned int j=0; j<Const::degfit-1; j++){				dparamsl[i][j] = Pl.get_coeff(j);				dparamsr[i][j] = Pr.get_coeff(j);			}		}		//On calcule les valeurs de Q et gradQ sur la grille		double min = -50;// *min_element(xtest.begin(), xtest.end());		double max = 50;// *max_element(xtest.begin(), xtest.end());		double xmin = min-((max-min)/10.);		double xmax = max+((max-min)/10.);		double pasx = (xmax-xmin)/(1.*Const::n_x-1.);		vector<double> xgrid(Const::n_x, 0);		vector<double> Qgrid(Const::n_x, 0);		vector<double> gradQgrid(Const::n_x, 0);		double xact = xmin;		j=-1;		for(unsigned int i=0; i<Const::n_x; i++){			if(j<1.*(xextr.size()-1.)){				if(xact>xextr[j+1]){					j++;				}			}			if(j==-1){				Qgrid[i] = Poly(paramsl[0])(xact);				gradQgrid[i] = Poly(dparamsl[0])(xact);			}			else if(j==xextr.size()-1){				Qgrid[i] = Poly(paramsr[xextr.size()-1])(xact);				gradQgrid[i] = Poly(dparamsr[xextr.size()-1])(xact);			}			else{				Qgrid[i] = interpolationl1D(xextr[j], xextr[j+1], Poly(paramsr[j])(xact), Poly(paramsl[j+1])(xact), xact);				gradQgrid[i] = interpolationl1D(xextr[j], xextr[j+1], Poly(dparamsr[j])(xact), Poly(dparamsl[j+1])(xact), xact);			}			xgrid[i] = xact;			xact+=pasx;		}		for(unsigned int i=0; i<Const::n_pt; i++){			//v[i] += -gradQ(x[i])/Const::m*Const::pas_t-pot.deriv(x[i], 0)/Const::m*Const::pas_t;			int j = int((x[i]-xmin)/pasx);			if(j>=0 and j<Const::n_x-1){				v[i] += -interpolationl1D(xgrid[j], xgrid[j+1], gradQgrid[j], gradQgrid[j+1], x[i])/Const::m*Const::pas_t-pot.deriv(x[i], 0)/Const::m*Const::pas_t;				x[i] += v[i]*Const::pas_t;			}			else{				v[i] = 0;				x[i] += v[i]*Const::pas_t;			}			j = int(round((x[i]-Const::min_x)/Const::pas_x));			if(j>=0 and j<Const::n_x){				R[j]+=1.;			}		}		for(unsigned int i=0; i<Const::n_test; i++){			int j = int((xtest[i]-xmin)/pasx);			if(j>=0 and j<Const::n_x-1){				vtest[i] += -interpolationl1D(xgrid[j], xgrid[j+1], gradQgrid[j], gradQgrid[j+1], xtest[i])/Const::m*Const::pas_t-pot.deriv(xtest[i], 0)/Const::m*Const::pas_t;				xtest[i] += vtest[i]*Const::pas_t;			}			else{				vtest[i] = 0;				xtest[i] += vtest[i]*Const::pas_t;			}		}		if(t%100 == 0){			savetraj(xtest, vtest, vtest, t);			save2D(xtest, Q, t+1);			save2D(xgrid, Qgrid, t+2);			save2D(xtest, g, t);			//save2D(xtest, lapg, t+4);		}		if(t%1000 == 0){			cout<<t<<" "<<Const::pas_t*t<<endl;			//saveVeff(&pot, param, t);		}	}	*/		int N = Const::degfit-1;	vector<vector<int>> bin;	binom(N, bin);		//Grille dynamique + DAF pour calculer gradQ	//Calcul des polynomes d'Hermite	vector<Poly> Hermite(max(Const::degH, Const::deg+2));	vector<double> poly0(1, 0);	poly0[0] = 1.;	vector<double> poly1(2, 0);	poly1[1] = 2.;	Hermite[0] = Poly(poly0);	Hermite[1] = Poly(poly1);	for(unsigned int i=2; i<Const::degH; i++){		Hermite[i] = Hermite[1]*Hermite[i-1] - (2.*(i-1))*Hermite[i-2];	}		//Création de la fonction d'onde initiale	//double x0 = 3.;	//double p0 = 0.;	//double s0 = 5.;	//PotOH pot(0.005);	//Double gaussienne	double x0 = -2.;	double p0 = 0.;	double s0 = 2.;	PotFis pot(-40., 0., 10., 70., 1000., 1000.);	//PotConst pot(0);	//PotQuart pot(0.01, 1./100000.);	//PotQuart pot(0, 1./100000.);	//Création des trajectoires	Gaussian psi0(x0, p0, s0);	//DGaussian psi0(x0, s0);	vector<double> x(Const::n_pt, 0);	vector<double> v(Const::n_pt, 0);	vector<double> R(Const::n_x, 0);	//Création des trajectoires tests	vector<double> xtest(Const::n_test, 0);	vector<double> vtest(Const::n_test, 0);	vector<double> Rtest(Const::n_test, 0);	//Initialisation	for(unsigned int i=0; i<Const::n_pt; i++){		x[i] = psi0.tirage();		v[i] = p0/Const::m;	}	for(unsigned int i=0; i<Const::n_test; i++){		xtest[i] = x0-3.*s0+(6.*s0/(Const::n_test-1.))*i;		vtest[i] = p0/Const::m;	}	//save2D_discret(R, 0);	for(unsigned int t=0; t<Const::n_t; t++){		//On remet R à 0		for(unsigned int i=0; i<Const::n_x; i++){			R[i] = 0;		}		//on calcule tout les 100 pas de temps la valeur de R sur les particules tests		if(t%100 == 0){			for(unsigned int i=0; i<Const::n_test; i++){				Rtest[i]=0;			}			for(unsigned int i=0; i<Const::n_pt; i++){				for(unsigned int j=0; j<Const::n_test; j++){					for(unsigned int k=0; k<=(Const::degH-1)/2; k++){						if(abs(x[i]-xtest[j])<1000. && x[i]>-40. && x[i]<40.){							Rtest[j] += pow(-1, k)/pow(4., k)/factorial(k)*Hermite[2*k]((x[i]-xtest[j])/pow(2., 0.5)/Const::sigherH)*exp(-pow((x[i]-xtest[j])/pow(2., 0.5)/Const::sigherH, 2.))/Const::n_pt*pow(2.*M_PI*pow(Const::sigherH, 2.), -0.5);						}					}				}			}		}		//On calcule Q par convolution		vector<double> g(Const::n_test, 0);		//for(unsigned int i=Const::n_loc; i<Const::n_test-Const::n_loc; i++){		//	for(unsigned int j=i-Const::n_loc; j<=i+Const::n_loc; j++){		//		for(unsigned int k=0; k<=(Const::deg-1)/2; k++){		//			g[i]+= pow(-1, k)/pow(4., k)/factorial(k)*Hermite[2*k]((xtest[i]-xtest[j])/pow(2., 0.5)/Const::sigher)*exp(-pow((xtest[i]-xtest[j])/pow(2., 0.5)/Const::sigher, 2.))*pow(2.*M_PI*pow(Const::sigher, 2.), -0.5)*Rtest[j];		//		}		//	}		//}		for(unsigned int i=0; i<Const::n_test; i++){			for(unsigned int j=((i-Const::n_loc>=0)?i-Const::n_loc:0); j<=((i+Const::n_loc<Const::n_test)?i+Const::n_loc:Const::n_test-1); j++){				for(unsigned int k=0; k<=(Const::deg-1)/2; k++){					g[i]+= pow(-1, k)/pow(4., k)/factorial(k)*Hermite[2*k]((xtest[i]-xtest[j])/pow(2., 0.5)/Const::sigher)*exp(-pow((xtest[i]-xtest[j])/pow(2., 0.5)/Const::sigher, 2.))*pow(2.*M_PI*pow(Const::sigher, 2.), -0.5)*Rtest[j];				}			}		}		vector<double> logg;		vector<double> xl;		for(unsigned int i=0; i<g.size(); i++){			if(g[i]>0 and xtest[i]>-40 and xtest[i]<40){				logg.push_back(log(g[i]));				xl.push_back(xtest[i]);			}		}		int im = 0;		double xm = xl[0];		double lm = logg[0];		int im2 = 0;		double xm2 = xl[0];		double lm2 = logg[0];		int imin1 = 0;		double xmin1 = 0;		double lmin1 = 0;		for(unsigned int i=1; i<xl.size()-1; i++){			if(logg[i]>lm && logg[i]>logg[i-1] && logg[i]>logg[i+1]){				im=i;				xm=xl[i];				lm=logg[i];			}			if(logg[i]>lm2 && logg[i]>logg[i-1] && logg[i]>logg[i+1] && abs(xm-xl[i])>5){				im2=i;				xm2=xl[i];				lm2=logg[i];			}		}		if(im2!=0){			imin1= im;			xmin1 = xm;			lmin1 = lm;			for(unsigned int i=im; i<im2; i++){				if(logg[i]<lmin1 && logg[i]<logg[i-1] && logg[i]<logg[i+1]){					imin1=i;					xmin1=xl[i];					lmin1=logg[i];				}			}			cout<<xm<<" "<<xmin1<<" "<<xm2<<endl;		}		vector<int> iinfb;		for(unsigned int i=2; i<xl.size()-2; i++){			if((logg[i+2]+logg[i]-2*logg[i+1])*(logg[i-2]+logg[i]-2*logg[i-1])<0){				iinfb.push_back(i);			}		}		int S = 0;		int Sn = 0;		vector<int> iinf;		for(unsigned int i=0; i<((iinfb.size()>0)?iinfb.size()-1:0); i++){			if(abs(iinfb[i+1]-iinfb[i])<=2){				S+=iinfb[i];				Sn++;			}			else{				S+=iinfb[i];				Sn++;				if(round(S/(1.*Sn))>im){					iinf.push_back(round(S/(1.*Sn)));				}				S=0;				Sn=0;			}		}		if(S!=0 && round(S/(1.*Sn))>im){			iinf.push_back(int(S/(1.*Sn)));		}		if(t%100==0){			for(unsigned int i=0; i<iinf.size(); i++){				cout<<iinf[i]<<" ";			}			cout<<endl;			for(unsigned int i=0; i<iinfb.size(); i++){				cout<<iinfb[i]<<" ";			}			cout<<endl;			cout<<im<<endl;		}		/*		vector<double> paramg(1, 0);		vector<double> paramd(1, 0);				vector<double> paramcg(1, 0);		vector<double> paramcd(1, 0);		if(im2==0){			if(!interpolation_hermite(xl, logg, 0, im, paramg, 3)){				cout<<"Problème à gauche"<<endl;				return 0;			}			int j=30;			while(!interpolation_hermite(xl, logg, im, paramd, 10, j) && j>10){				j-=5;			}			if(!interpolation_hermite(xl, logg, im, paramd, 10, j)){				cout<<"Problème à droite"<<endl;				return 0;			}		}		else{			if(!interpolation_hermite(xl, logg, 0, im, paramg, 3)){				cout<<"Problème à gauche"<<endl;				return 0;			}			if(!interpolation_hermite(xl, logg, imin1, im, paramcg, 3)){				cout<<"Problème à centre gauche"<<endl;				return 0;			}			if(!interpolation_hermite(xl, logg, imin1, im2, paramcd, 3)){				cout<<"Problème à centre droite"<<endl;				return 0;			}			int j=30;			while(!interpolation_hermite(xl, logg, im2, paramd, 10, j) && j>10){				j-=5;			}			if(!interpolation_hermite(xl, logg, im2, paramd, 10, j)){				cout<<"Problème à droite"<<endl;				return 0;			}		}		*/		vector<double> paramg(1, 0);		vector<double> paramd(1, 0);		if(iinf.size()==0){			iinf.push_back(im+10);			iinf.push_back(xl.size()-2);		}		else{			int piinf = iinf[0];			iinf.clear();			iinf.push_back(xl.size()-2);			iinf.push_back(piinf);		}		iinf.push_back(im);		//iinf.push_back(im2);		//iinf.push_back(imin1);		if(!interpolation_hermite(xl, logg, iinf, paramd)){			cout<<"Probleme droite"<<endl;			return 0;		}		vector<int> igs;		igs.push_back(im);		igs.push_back(2);		igs.push_back(im-5);		if(!interpolation_hermite(xl, logg, igs, paramg)){			cout<<"Probleme gauche"<<endl;			return 0;		}		vector<double> xgrid;		vector<double> loggrid;		vector<double> Qgrid;		vector<double> gQgrid;		/*		Poly Qg = calc_Q(paramg);		Poly gQg = calc_gradQ(paramg);		Poly Qd = calc_Q(paramd);		Poly gQd = calc_gradQ(paramd);		Poly Qcg;		Poly gQcg;		Poly Qcd;		Poly gQcd;		if(im2!=0){			Poly Qcg = calc_Q(paramcg);			Poly gQcg = calc_gradQ(paramcg);			Poly Qcd = calc_Q(paramcd);			Poly gQcd = calc_gradQ(paramcd);		}		if(im2==0){			for(unsigned int i=0; i<Const::n_x; i++){				xgrid.push_back(Const::min_x+i*Const::pas_x);				if(xgrid[i]<xm){					loggrid.push_back(Poly(paramg)(xgrid[i]));					Qgrid.push_back(Qg(xgrid[i]));					gQgrid.push_back(gQg(xgrid[i]));				}				else{					loggrid.push_back(Poly(paramd)(xgrid[i]));					Qgrid.push_back(Qd(xgrid[i]));					gQgrid.push_back(gQd(xgrid[i]));				}			}		}		else{			for(unsigned int i=0; i<Const::n_x; i++){				xgrid.push_back(Const::min_x+i*Const::pas_x);				if(xgrid[i]<xm){					loggrid.push_back(Poly(paramg)(xgrid[i]));					Qgrid.push_back(Qg(xgrid[i]));					gQgrid.push_back(gQg(xgrid[i]));				}				else if(xgrid[i]>=xm && xgrid[i]<xmin1){					loggrid.push_back(Poly(paramcg)(xgrid[i]));					Qgrid.push_back(Qcg(xgrid[i]));					gQgrid.push_back(gQcg(xgrid[i]));				}				else if(xgrid[i]>=xmin1 && xgrid[i]<xm2){					loggrid.push_back(Poly(paramcd)(xgrid[i]));					Qgrid.push_back(Qcd(xgrid[i]));					gQgrid.push_back(gQcd(xgrid[i]));				}				else{					loggrid.push_back(Poly(paramd)(xgrid[i]));					Qgrid.push_back(Qd(xgrid[i]));					gQgrid.push_back(gQd(xgrid[i]));				}			}		}		*/		Poly Qg = calc_Q(paramg);		Poly gQg = calc_gradQ(paramg);		Poly Qd = calc_Q(paramd);		Poly gQd = calc_gradQ(paramd);		for(unsigned int i=0; i<Const::n_x; i++){			xgrid.push_back(Const::min_x+i*Const::pas_x);			if(xgrid[i]<xm){				loggrid.push_back(Poly(paramg)(xgrid[i]));				Qgrid.push_back(Qg(xgrid[i]));				gQgrid.push_back(gQg(xgrid[i]));			}			else{				loggrid.push_back(Poly(paramd)(xgrid[i]));				Qgrid.push_back(Qd(xgrid[i]));				gQgrid.push_back(gQd(xgrid[i]));			}		}		double xmin = Const::min_x;		double pasx = Const::pas_x;		for(unsigned int i=0; i<Const::n_pt; i++){			int j = int((x[i]-xmin)/pasx);			if(j>=0 and j<Const::n_x-1){				v[i] += -interpolationl1D(xgrid[j], xgrid[j+1], gQgrid[j], gQgrid[j+1], x[i])/Const::m*Const::pas_t-pot.deriv(x[i], 0)/Const::m*Const::pas_t;				x[i] += v[i]*Const::pas_t;			}			else{				v[i] = 0;				x[i] += v[i]*Const::pas_t;			}			j = int(round((x[i]-Const::min_x)/Const::pas_x));			if(j>=0 and j<Const::n_x){				R[j]+=1.;			}		}		for(unsigned int i=0; i<Const::n_test; i++){			int j = int((xtest[i]-xmin)/pasx);			if(j>=0 and j<Const::n_x-1){				vtest[i] += -interpolationl1D(xgrid[j], xgrid[j+1], gQgrid[j], gQgrid[j+1], xtest[i])/Const::m*Const::pas_t-pot.deriv(xtest[i], 0)/Const::m*Const::pas_t;				xtest[i] += vtest[i]*Const::pas_t;			}			else{				vtest[i] = 0;				xtest[i] += vtest[i]*Const::pas_t;			}		}		if(t%100==0){			cout<<t<<" "<<t*Const::pas_t<<endl;			savetraj(xtest, vtest, vtest, t);			save2D(xl, logg, t);			save2D(xgrid, loggrid, t+1);		}	}	return 0;}